{"/":{"title":"ðŸ—¡ lonerapier.xyz","content":"\nI always wanted a corner of my own on this wild zoo that we call internet, and finally made one. I'm Sambhav and I try to write as much as I can to slow down my brain. It's mostly my thoughts and notes which I occassionally write after listening to a podcast.\n\nPresently, I work as a Software Engineer at an EdTech startup and have discovered my love for complex engineering and writing. I am a big fan of OSS and try to contribute as much as I can to some mind-blowing projects made and maintanined by truly amazing folks.\n\nMy curiosity generally takes me to some unseen and uninviting places. Currently, it's all about crypto and web3.\n\nI'll try to mold this website into something of my own.\n","lastmodified":"2022-09-20T06:01:26.542238485Z","tags":null},"/posts/ECC":{"title":"Elliptic Curve Cryptography","content":"\n\n## Elliptic Curve Cryptography\n\n$$ y^2 = x^3 + ax^2 + bx + c $$\n\nsecp256k1: used by Bitcoin and Ethereum to implement public key cryptography. Elliptic curve over a field $z_p$ where $p$ is a 256-bit prime.\n\nECDSA: Elliptic Curve Digital Signature Algorithm\n\nPublic key cryptography uses this method to calculate public keys which is a point on ECC curve.\n\n$$ K = (k * G) \\% p $$\n\n- K = 512-bit public key\n- k = 256-bit randomly generated private key\n- G = base point on the curve\n- p = prime number\n\nTake a base point $G$, add it $n$ (private key) times to make $nG (\\% p)$ (public key).\n\n\u003e **Note**: addition here means addition in elliptic curve and not addition in field of integers mod p.\n\nOrder of a base point is when keys generated using this point starts to form a cycle. Max number of points on the curve.\n\nThus, choosing a good base point is necessary in any public key generation curves.\n\nsecp256k1:\n\n```other\nx = 0x79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798\ny = 0x483ADA7726A3C4655DA4FBFC0E1108A8FD17B448A68554199C47D08FFB10D4B8\np = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F\n```\n\nThe order is:\n\n```other\nN = FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141\n```\n\nEthereum public keys are serialization of 130 hex characters\n\n```other\n04 + x-coord (64) + y-coord (64)\n```\n\n\u003e 04 is prefixed as it is used to define uncompressed point on the ECC.\n\nEthereum addresses are hexadecimal numbers, identifiers derived from the last 20 bytes of the Keccak256 hash of the public key.\n\n## EIP55\n\nMixed capitalisation of letters in the address\n\nTake keccak256 hash of the address, capitalize character if hex digit of hash is greater than 8.\n\n## Discrete Log Problem (DLP)\n\ndescribes that there are currently no known method for calculating point division on an elliptic curve.\n\n### Why Discrete logarithm?\n\nECC is significant because solving $k * G$ is trivial but obtaining $k$ from product $k * G$ is not.\n\nk*G can be obtained using Fast-Exponentiation algorithm but solving for k requires computing discrete logarithms.\n\n## Security\n\nBig-O Notation of discrete logarithm problem is $O(\\sqrt{n})$.\n\nBase point G, is chosen to be closer to $2^{256}$ and thus is in the order of 256.\n\nSo, $\\sqrt{256} = 128$ bits level of security is provided by curves like secp256k1.\n\n## secp256k1 v/s secp256r1\n\nsecp256k1 is a Koblitz curve defined in a characteristic 2 finite field while secp256r1 is a prime field curve.\n\nNot going into details as to what a characteristic 2 finite field is, we can specify secp256r1 as a pseudo-randomised curve and secp256k1 as completely random curve which canâ€™t be solved using discrete logarithm problem **yet**.\n\n## BLS Signatures\n\n\n## To-Read\n\n1. [https://medium.com/@VitalikButerin/exploring-elliptic-curve-pairings-c73c1864e627](https://medium.com/@VitalikButerin/exploring-elliptic-curve-pairings-c73c1864e627)\n2. [https://eth2book.info/altair/part2/building_blocks/signatures](https://eth2book.info/altair/part2/building_blocks/signatures)\n\n## Resources\n\n- [Group Theory | Brilliant Math \u0026 Science Wiki](https://brilliant.org/wiki/group-theory-introduction/)\n\n- [Picking a Base Point in ECC](https://medium.com/asecuritysite-when-bob-met-alice/picking-a-base-point-in-ecc-8d7b852b88a6)\n\n- [Whatâ€™s The Order in ECC?](https://medium.com/asecuritysite-when-bob-met-alice/whats-the-order-in-ecc-ac8a8d5439e8)\n\n- [https://github.com/ethereumbook/ethereumbook/blob/develop/04keys-addresses.asciidoc#elliptic_curve](https://github.com/ethereumbook/ethereumbook/blob/develop/04keys-addresses.asciidoc#elliptic_curve)\n\n- [Secp256k1 | River Glossary](https://river.com/learn/terms/s/secp256k1/)\n\n- [Discrete Log Problem (DLP) | River Glossary](https://river.com/learn/terms/d/discrete-log-problem-dlp/)\n\n- [Elliptic curves secp256k1 and secp256r1](https://www.johndcook.com/blog/2018/08/21/a-tale-of-two-elliptic-curves/)\n\n- [Why did Satoshi decide to use secp256k1 instead of secp256r1? - DappWorks](https://dappworks.com/why-did-satoshi-decide-to-use-secp256k1-instead-of-secp256r1/)\n\n- [Exploring Elliptic Curve Pairings](https://medium.com/@VitalikButerin/exploring-elliptic-curve-pairings-c73c1864e627)","lastmodified":"2022-09-20T06:01:26.542238485Z","tags":null},"/posts/Optimistic-Rollups":{"title":"Optimistic Rollups","content":"\n## Asserter/Checker Problem\n\n- Asserter makes a claim $A$, checker checks the claim for cost $C$ and gets R as reward, if successful.\n- If Asserter cheats without getting caught, Checker loses $L$ in the form of loss of items of value.\n- Two main threats to worry about: Laziness and Bribery\n- Bribery: Asserter bribes Checker more than the reward $R$. Prevent this by large bond by Asserter so that bribe canâ€™t be bigger than the reward $R$.\n- Laziness: Checker does not check intentionally.\n- If we assume, asserter cheats with prob. X, then\ncheckerâ€™s utility comes as:\n\n\u003e $-X*L$, if checker doesnâ€™t\n\u003e\n\u003e $R*X-C$, if checker checks\n\n- So, checking is only worthwhile, if utility of checking \u003e not checking.\n\n\u003e $X \u003e C/(R+L)$\n\n- Thus, *asserter* can cheat with random prob \u003c required and not get caught.\n- This doesnâ€™t depend on how much *asserter* gains from cheating, as long as itâ€™s non-zero which is a bad result.\n- Even adding more *checkers* doesnâ€™t help, as the reward gets distributed which only reduces *checkerâ€™s* incentives.\n\nReason this is a problem:\n\n- *Asserter* controls the behaviour of the checker, as the utility of checker depends on asserterâ€™s prob.\n- Need to add an attention parameter in *checkerâ€™s* incentives where checker pre-computes *asserterâ€™s* claim off-chain beforehand and has to verify it on-chain time to time.\n- Two new parameters:\n\n\u003e $P$, fraction of time *checker's* will post response\n\u003e\n\u003e $A$, penalty in case *checker* gives wrong answer\n\n- New equation becomes,\n\n$$R*X-C$$\n\n$$-L*X-P*A$$\n\n- If $P*A \u003e C$, then checking is better than not checking\n- cost of checking is low\n\n\u003e Assume 1 assertion / 5 mins and $C = $0.001$ If P = 0.3%, checker will deposit $3.\ncost per assertion = $0.0003 =\u003e $0.01*0.3%\ninterest cost of locking = $0.0003\ntotal cost = $0.0006\n\n- Multiple checkers need to submit proofs differently thus, scaling to multiple checkers efficient.\n\n## Technical Details\n\nChecker: private key $k$, public key $g^k$\n\nHash fn: $H$\n\nComputation to solve: $f(x)$\n\nAsserter challenge: $(x, g^r)$\n\nChecker post on-chain iff $H(g^{rk}, f(x)) \u003c T$\n\n\u003e Note: Only checker and asserter knows $g^k$ and $r$, and $T$ requires $f(x)$\n\nChecker can guess $f(x)$ with prob. G, then multiply deposit with $1/1-G$\n\n- Asserter publishes f(x), can challenge checker's response while publishing r\n- Check the accusation and penalise checker, half the deposit to asserter\n- If asserter $f(x)$ incorrect, accusation reverted.\n- Each checker will have different prob of posting on-chain due to use of private key, thus canâ€™t copy others computation.\n- Asserter now instead of bribing checker, will try to mislead him into giving false information on-chain.\n\n## Links\n\n[(Almost) Everything you need to know about Optimistic Rollup](https://research.paradigm.xyz/rollups)\n\n[The Cheater Checking Problem: Why the Verifierâ€™s Dilemma is Harder Than You Think](https://medium.com/offchainlabs/the-cheater-checking-problem-why-the-verifiers-dilemma-is-harder-than-you-think-9c7156505ca1)\n","lastmodified":"2022-09-20T06:01:26.542238485Z","tags":null},"/posts/SoK":{"title":"Communication Across Distributed Ledgers","content":"\n[Communication Across Distributed\nLedgers](https://eprint.iacr.org/2019/1128.pdf)\n\nAims to develop a guide for designing protocols bridging different types of blockchains (distributed ledgers).\n\nShows that CCC is impossible without **_third party._**\n\nPresents a framework keeping these trust assumptions in mind. Classifies current CCC protocols on the basis of framework.\n\n## Introduction\n\n- NB-AC (_Non-Blocking Atomic Commit_) is used in distributed databases to ensure that correct processes don't have to wait for crashed processes to recover.\n- Can be extrapolated to distributed ledgers by handling _byzantine failures._\n\n## Distributed Ledger Model\n\n- $X, Y$: Blockchains\n- $Lx$, $Ly$: ledgers with _states_ as dynamically evolving sequences of _transactions_\n- state of ledgers progresses in round _r._\n- $L^P[r]$: state of ledger _L_ at round _r_ after all txs till _r-1_, according to some party _P._\n- Consistency is defined by the system\n- ($TX$, $Lx^P[r]$): tx _TX_ is valid for _Lx_ at round _r_ according to _P._\n- $TX$ âˆˆ $L^P[r]$: TX is included in _L_ as position _r._\n- **Time** $L^P[t]$**:** ledger state at round r or time t.\n\n**Persistence**: $L^P[t] \u003c= L^Q[tâ€™]$, $L^P$ at time $t$ is prefix of $L^Q$ at time $t$â€™.\n\n**Liveness**: if tx $TX$ is included in ledger $L$ at time $t$, then it will appear in ledger at time $t$â€™.\n\n### CCC System Model\n\n- $P: TX_P, Q: TX_Q$: separate processes running on two different ledgers with txs\n- $P$ possesses a description $d_Q$ which characterises the transaction $TX_Q$, while $Q$ possesses $d_P$ which characterises $TX_P$\n- Thus, $P$ wants $Q$ to be written to $Ly$ and vice-versa.\n- $m_P, m_Q$: boolean error variables for malicious processes\n\n## Formalisation of correct CCC\n\nGoal: sync of P and Q such that Q is included iff P is included. For example, they can constitute an exchange of assets which must be completed atomically.\n\n**Effectiveness:** if both correct, then both will be included, otherwise none\n\n**Atomicity**: no outcome in which $TX_P$ included but $TX_Q$ not at time $t$â€™ or vice versa.\n\n**Timeliness**: If a process behaves correctly, $TX_P$ will be included and $Q$ will verify. It is a liveness property.\n\n## Generic CCC Protocol\n\n\u003e $u_x$: liveness delay\n\u003e\n\u003e $k_x$: depth parameter\n\n1. **Setup**: inherently done by both blockchains due to the properties defined above\n2. **Pre-Commit on X**: $P$ writes $TX_P$ to $L^P_X$ at time $t$ in round $r$. Due to persistence and liveness, all honest parties report TX_P as valid in $r+u_x+k_x$.\n3. **Verify**: Q verifies $TX_P$.\n4. **Commit on Y:** $Q$ writes $TX_Q$ to $L^Q_Y$ at time $t$â€™ in round $r$â€™.\n5. **Abort**: revert $TX_P$ on $Lx$ in case of verification failure or $Q$ fails\n\n![Image.png](https://res.craft.do/user/full/e83dd57b-d460-d205-2243-2f6ed8de496a/doc/2875A4D6-F00A-45A2-96EE-7222C31E634F/490D063A-EBE6-49DA-A5C7-D53342042837_2/q21xMyyBAkdRygr7FHp2PQr7J452ctL6JuxUysHHwccz/Image.png)\n\nCCC protocols follow two-phase commit design.\n\nPre-commit and commit on Y is executed in parallel following verification and abortion, if required.\n\n## Impossibility of CCC without TTP (Trusted Third Party)\n\nAnalogous to **_Fair Exchange_** Problem.\n\nTTP is basically any entity, be it individual or a committee that either confirms a tx has been successfully included or enforce correct behaviour of $Q$ on $Ly$.\n\nLemma 1: Let $M$ be a system model. Let $C$ be a protocol which solves $CCC$ in $M$. Then there exists a protocol $S$ which solves _Fair Exchange_ in $M$.\n\nSketch: to complete exchange, $TX_Q \\in  Ly$ and $TX_P \\in Lx$.\n\n- _effectiveness_ enforces correct transfer for correct behaviour.\n- Persistence and liveness enforce both txs to be eventually written to respective ledgers.\n- Atomicity $\u003c-\u003e$ Strong Fairness in Fair exchange\n\nSmart contracts or code based solutions can be used to write $TX_Q$ to $Y$, in this case consensus becomes TTP to execute this smart contract.\n\nTTP either becomes the process $P$ itself or another party which submits proof of $P$ inclusion to $Q$.\n\nMany other frameworks for designing a CCC protocol:\n\n- Incentivizing third party\n- Slashing the rewards\n- Optimistic\n\n## CCC Design Framework\n\nThree main types of trust model:\n\n- TTP\n- Synchrony\n- Hybrid\n\n### Pre-Commit Phase\n\n#### Model 1: TTP (Coordinators)\n\nCan participate in two ways:\n\n- Custody of Assets: taking control of protocol participant funds to enforce rules\n- Involvement in consensus: in case of smart contracts, when consensus participants are TTP\n\nCoordinator Implementations\n\n- External Custodians: Committee\n- Consensus Level Custodians (Consensus Committee)\n- External Escrows (Multisig Contracts)\n\n#### Model 2: Synchrony (Locking)\n\n- Locks based on hashes\n- Locks based on signatures\n- Timelock puzzles \u0026 Verifiable delay fns\n- Smart Contracts\n\n#### Model 3: Hybrid\n\nWatchtowers (Other external parties) to be used as fallback if one of the service fails or crashes\n\n### Verification Phase\n\nSame models but applied on verification part\n\n1. External Validators/Smart Contracts\n2. Direct Observation/Relay SCs (Using light clients)\n3. Hybrid using watchtowers\n\n### Abort Phase\n\n## Classification of Existing Protocols\n\n### Exchange Protocols\n\nAtomic exchange of digital goods: $x$ on Chain $X$ again $y$ on $Y$. Both parties pre-commit, then verify and abort in case of failure.\n\n#### Pre-Commit\n\nDone through atomic swaps\n\n- Both parties lock assets on-chain with identical release conditions. _Hashed Timelock contracts_ are the closest implementation of symmetric locks. Signature locks using _ECDSA_ are also used.\n- On turing-complete blockchains, atomic swaps can be handled through smart contracts which can verify the state of chain $Y$ (_chain relay_).\n- Hybrid: symmetric with TTP is used to solve usability challenges in atomic swaps.\n\n#### Verify\n\nDone through external validators in symmetric swaps or through chain relays in SPV based atomic swaps.\n\n#### Abort\n\nTimelocks are set up on assets for a pre-defined duration to prevent indefinite lock up in case of failures.\n\n### Migration Protocols\n\nMigrate the asset $x$ from chain $X$ using write locks on $x$ preventing further use on $X$ and creating a wrapped version of same asset on $Y$.\n\nFour main use cases of these protocols:\n\n- Wrapped version of assets between chains\n- communication b/w shards\n- sidechains\n- bootstrapping a new chain\n\n#### Pre-commit\n\nRelies on a single/committee based external custodian for TTP or through multisigs.\n\n**Sidechains**: same approach of depositing on chain $x$ controlled via multisigs which approve asset $y$ on chain $Y$.\n\n**Shards**: utilises the same security and consensus model as the main chain is same for all shards.\n\n_Bi-directional chain relays_ can also be used if both chains support smart contracts and thus, locking/minting of assets can be handled through these contracts.\n\n**Proof of Burn**: used for uni-directional flow as asset $x$ is burned on chain $X$.\n\n#### Verify\n\n- Chain relay contracts\n- Consensus committees to sign to verify pre-commit step.\n\n#### Abort\n\nMigration protocol doesnâ€™t have explicit abort phase.\n\n## CCC Challenges\n\n### Heterogeneous Models and Parameters Across Chains\n\n- Different parameters used by different chains\n- security models\n- consensus differences: consensus execution, finality\n\n### Cryptographic Primitives\n\ndifferent cryptographic algorithms for hash locks or signatures\n\nZK proofs may provide a workaround but increases complexity, communication costs.\n\n### Collateralization and Exchange Rates\n\nUsing collaterals to prevent malicious behaviour among custodians or TTPs, incentivising correct behaviour but different types and rates of collateral b/w different chains.\n\nDynamic Collateralization based on exchange rates among different blockchains\n\n#### Lack of Formal Security Analysis\n\n- Replay Attacks on state verification: if proofs are submitted multiple times either on the same chain or on different chains can lead to multiple spendings of assets.\n- Data availability: timely requirements of proofs and data, if not reached in time, leads to incorrect behaviour of process.\n\nNeed more research on this topic as current solution increases complexity and decreases efficiency.\n\n#### Lack of Formal Privacy Analysis\n\ndidnâ€™t understand perfectly\n\n### Upcoming Research\n\n- Interoperability chains: Cosmos and polkadot Layer 0 based ecosystems.\n- Light Clients: for better verification\n- Off-Chain Protocols\n  - Communication across off-chain channels\n  - Communication b/w on-chain and off-chain networks\n","lastmodified":"2022-09-20T06:01:26.542238485Z","tags":null},"/posts/eth-basics":{"title":"Ethereum Yellow Paper","content":"\nTransaction based state-machine\n\nstate of the blockchain changes after executing transactions.\n\nstores states in ***state root***\n\n## Accounts\n\n20-byte hex addresses whose state is stored on the blockchain\n\nTwo types of accounts:\n\n1. EOA: externally owned account\n2. Contract Accounts\n\n## Each accounts has four parts:\n\n1. Nonce: for EOA, number of transactions sent from the address. For Contracts, number of contracts creations.\n2. Balance: amount of ether owned by the account.\n3. storageRoot: Merkle-Patricia tree that stores data related to the account. Stored in the top-level state root tree.\n4. codeHash: For EOA, hash of empty string. For contracts, hash of the init code.\n\n## Transactions\n\nPiece of data signed by an external actor.\n\nTwo types of txs:\n\n1. Transaction which result in message calls\nMessage Calls: Done by contract account, when executing `CALL` opcode.\n2. Contract creation\n\nFields in a tx:\n\n1. nonce\n2. gasLimit\n3. gasPrice\n4. to\n5. value\n6. v, r, s: signature identifying sender\n7. init: in case of contract creating tx, returns code of the contract without constructor\n8. data: in case of message call tx, data being passed in call\n\n## Blocks\n\naggregate transactions and include in the blockchain\n\nContains:\n\n1. parentHash\n2. ommerHash\n3. beneficiary\n4. stateRoot\n5. transactionsRoot\n6. receiptsRoot\n7. timestamp\n8. number\n9. difficulty\n10. gasLimit\n11. gasUsed\n12. extraData\n13. mixHash\n14. nonce\n\n## GHOST\n\n`GHOST` protocol is used by ethereum to prevent mining centralization and enhance protocol security.\n\nLongest chain isnâ€™t just the chain with more blocks as ancestor, but it also includes other stale(uncle) blocks in the calculation.\n\nUncle blocks are child of the ancestor of the block and not directly related to the block.\n\n## RLP\n\nIt is the data encoding used by the protocol to store data in tries.\nThere are several rules for encoding mentioned below.\n\n[Data structure in Ethereum | Episode 1: Recursive Length Prefix (RLP) Encoding/Decoding.](https://medium.com/coinmonks/data-structure-in-ethereum-episode-1-recursive-length-prefix-rlp-encoding-decoding-d1016832f919)\n\n## HP Encoding\n\nThis encoding is used for trie paths.\n\n[Data structure in Ethereum | Episode 1+: Compact (Hex-prefix) encoding.](https://medium.com/coinmonks/data-structure-in-ethereum-episode-1-compact-hex-prefix-encoding-12558ae02791)\n\n[Ethereum: Tutorials - LayerX Research](https://scrapbox.io/layerx/Ethereum:_Tutorials)\n\nPatricia tree\n\n[patricia-tree](https://eth.wiki/fundamentals/patricia-tree)\n[Understanding trie databases](https://medium.com/shyft-network-media/understanding-trie-databases-in-ethereum-9f03d2c3325d)\n\n","lastmodified":"2022-09-20T06:01:26.630238632Z","tags":null},"/posts/eth-consensus":{"title":"ETH Consensus","content":"\nELI5 understanding of ETH 2.0 specs\n\n**Safety**: guarantees that something bad never happen. Examples: Tendermint from Cosmos that uses BFT style consensus.\n\n**Liveness**: something good eventually occurs. Example: POW, Casper used by Ethereum.\n\n## **Why PoS**\n\nAn individual autonomy should always be greater than the power of any state. Cryptography solved this issue, by using ECC, individuals can now have a pair of keys that only he can access and thus, has the power to defend even state-level attacks.\n\nConsensus in blockchain is what drives the value of the network, and from where the network derives its value. No attacker should have incentives to attack the network for his own gain. PoW style networks are based on rewards where a consensus participant has almost nothing to lose in case the network is attacked. PoS solves this problem by allocating stakes to network particpants and imposing penalties in case of any malicious actors in the system. The ratio of rewards v/s penalties determines the incentives of consensus participants to behave honestly as penalties are directly proportional to number of wrong validations, if more validators behave maliciously, then slashing is higher.\n\n## Different types of PoS\n\n- Chain-Based PoS: pseudo-random validator assigned at each time slot to create new block behind a previous block\n- BFT-style PoS: (partially synchronous) randomly assigned validator proposes a block and canonical chain is assigned using a voting process on which each validator votes for the valid chain\n\n## **Proof Of Stake**\n\n- Stake ETH to become validator\n  - For each 32 ETH staked, a validator is activated. Anyone can stake any number of ETHs and activate and control validators and execute **validator clients**.\n  \u003e Validator clients has the functionality of following and reading the Beacon Chain. A validator client can make calls into the Beacon nodes.\n- Validator, responsible for adding blocks to the chain by verifying txs and policing blocks being added by other validators\n  - Earns by successfully adding blocks\n  - Staked eths slashed if illegal txs added\n- Save Energy as selected randomly and not competing\n- No need to mine, just validate blocks known as **Attesting**\n\n## **Phases**\n\n- Beacon Chain\n- Sharding\n- Execution\n\n## **Sharding**\n\n- Scaling nodes horizontally\n- At least 128 Validators randomly assigned to a shard where a new block will be added in each slot of an epoch i.e.,Â after 32 slots\n- ETH plans for 64 shards\n\n## **Beacon Chain**\n\n- Main functioning body in the blockchain, managing all the shards and the validators\n- Functions as heart of the chain\n- Creates **committee**, which are the validators used to validate a blockchain on which everyone verifies, stores and downloads\n\n## **Slots \u0026 Epochs**\n\n- Chain is divided into **slots** and **epochs**\n- **Slot** â†’ timeframe to propose and validate a new block\n  - In a time period pre-determined in a blockchain, 12 seconds in case of Ethereum, all shard blocks are added into the blockchain\n  - Slots can be empty in case a validator fails to **propose** the block or the committee fails to attest\n  - Genesis blocks added to both Beacon chain and shards at block 0\n- **Epochs** â†’ 32 slots comprises an epoch. \u003e 12 sec * 32 slots = 6.4 mins\n\n## **Crosslinks**\n\n- reference to shard blocks\n- basically the proof that a shard is valid\n- created at beacon chain for every successful block proposed by a shard\n- only after a crosslink does a validator get its reward\n\n## **Committee**\n\n- **Beacon chain** gets its name from the random numbers that it emits to the public\n- uses RANDAO process to randomly select a group of validators for an epoch to a shard to attest transactions in a block\n- crosslinks are made after attestation from validators of that slot\n- Every epoch, validators randomnly assigned to a slot which is then subdivided into committees.\n- Each committee is assigned a particular shard and they attempt to crosslink a shard block to Beacon chain head in order to gain rewards.\n- 64 shards, each assigned 128 validators per committee -\u003e Thus, has atleast 8192 validators\n\n### **Beacon Chain Checkpoints**\n\n![Beacon Chain Checkpoints](posts/assets/Beacon-Chain-Checkpoints.jpeg)\n\nA `checkpoint` or an `epoch boundary` is the first block in an epoch. If no such block, it is the most recent preceding block.\n\n### Votes\n\n- **`LMD GHOST`**: validator vote for beacon chain head, i.e. what they believe beacon chain head is.\n- **`Casper FFG`**: When casting LMD GHOST vote, validators also vote for checkpoint in current epoch, called `target`. This also includes previous epoch checkpoint called `source`.\n\n## Finality\n\n\u003e `Supermajority vote`: which is made by 2/3 of the total **balance** of all validators.\n\n![image](posts/assets/Beacon-Chain-Justification-and-Finalization.png)\n\nWhen an epoch checkpoint gets supermajority vote, it is said to be *justified*.\nAn epoch is *finalised* when it is justified and next epoch checkpoint gets justified.\nWhen a epoch checkpoint, i.e. slot gets finalised, all preceding blocks also gets finalised.\n\n- Finality is important as it gives gurantees to shards and ethereum parties regarding transactions.\n- Reduces complexity with cross-shard communications.\n\n## FLP Impossibility\n\n![image](posts/assets/FLP-Impossibility.png)\n\nIn a distributed system, it is not possible to simultaneously have safetly, liveness and full asynchrony unless some unreasonable assumptions are made.\n\nEthereum uses both `LMD-GHOST` and `Casper FFG` as its protocol to justify and finalise blocks.\n\n**LMD-GHOST** preferes liveness over safety in the form that validator can attest to a chain head and keep producing blocks while **Casper** prefers safety over liveness such that a block is finalised only when it is justified and in a later epoch, majority of validators attest it again to finalise it. Once, a block is finalised, it is added forever in the chain.\n\nDue to **LMD-GHOST** prefering liveness over safety, there is a chance of reorgs. Capser FFG helps here as it prefers safety and decisions made under Casper is considered final. It has phases, in which nodes indicate they'd like to agree on something(justification), then agree that they've seen each other agreeing(finalisation).\n\n## **Questions**\n\n1. MEV in PoS\n2. Reorgs\n\n## **Checkpoints**\n\n1. [https://ethereum.org/en/developers/docs/consensus-mechanisms/pos/](https://ethereum.org/en/developers/docs/consensus-mechanisms/pos/)\n2. [eth2book.info](https://eth2book.info/altair/contents)\n3. [https://github.com/ethereum/annotated-spec/blob/master/phase1/beacon-chain.md#introduction](https://github.com/ethereum/annotated-spec/blob/master/phase1/beacon-chain.md#introduction)\n4. [https://ethos.dev/beacon-chain/](https://ethos.dev/beacon-chain/)\n5. [https://ethresear.ch/t/two-ways-to-do-cross-links/2074](https://ethresear.ch/t/two-ways-to-do-cross-links/2074)\n6. [https://vitalik.ca/general/2017/12/31/pos_faq.html](https://vitalik.ca/general/2017/12/31/pos_faq.html)\n7. [https://medium.com/codechain/safety-and-liveness-blockchain-in-the-point-of-view-of-flp-impossibility-182e33927ce6](https://medium.com/codechain/safety-and-liveness-blockchain-in-the-point-of-view-of-flp-impossibility-182e33927ce6)\n8. [https://medium.com/@VitalikButerin/a-proof-of-stake-design-philosophy-506585978d51](https://medium.com/@VitalikButerin/a-proof-of-stake-design-philosophy-506585978d51)\n9. [Ben Eddington blog](https://hackmd.io/@benjaminion/eth2_news/https%3A%2F%2Fhackmd.io%2F%40benjaminion%2Fwnie2_220311)\n10. [eth2book](https://eth2.incessant.ink/book/03__eth1/07__clients.html)\n11. \u003chttps://arxiv.org/pdf/2203.01315.pdf\u003e\n12. [LMD GHOST and Casper FFG](https://blog.ethereum.org/2020/02/12/validated-staking-on-eth2-2-two-ghosts-in-a-trench-coat/)\n13. [https://blog.ethereum.org/2019/12/30/eth1x-files-state-of-stateless-ethereum/](https://blog.ethereum.org/2019/12/30/eth1x-files-state-of-stateless-ethereum/)\n14. [Understanding validator effective balance](https://www.attestant.io/posts/understanding-validator-effective-balancehttps://www.attestant.io/posts/understanding-validator-effective-balance/)\n15. [0xfoobar's Proof of Stake](https://0xfoobar.substack.com/p/ethereum-proof-of-stake)\n","lastmodified":"2022-09-20T06:01:26.630238632Z","tags":null},"/thoughts/Curve-wars":{"title":"Curve Wars","content":"\n## Resources\n\n- [defi 80/20](https://alexlittlewood.com/defi-8020)\n- [Back to the basics: uniswap, balancer, curve](https://medium.com/@kinaumov/back-to-the-basics-uniswap-balancer-curve-e930c3ad9046)\n- [Back to the basics: compound, aave](https://medium.com/@kinaumov/back-to-the-basics-compound-aave-436a1887ad94)\n- [Curve wars](https://every.to/almanack/curve-wars)\n- [The Curve Wars](https://kyrianalex.substack.com/p/the-curve-wars)\n- [curve v2 parameters](https://nagaking.substack.com/p/deep-dive-curve-v2-parameters)","lastmodified":"2022-09-20T06:01:26.630238632Z","tags":null},"/thoughts/UniswapV3":{"title":"Uniswap V3","content":"\nFeatures:\n\n- Concentrated Liquidity\n- Improved Price Oracle\n- Flexible Fees\n\n## Uniswap V2 IL\n\nMarket with Liquidity $L$ and Asset $X$ and $Y$ with amounts $x$ and $y$ respectively.\n$$x*y = L^2$$\nInitial Price $P$ of asset $X$ in terms of $Y$ = $y/x$, with price movement from $P$ to $P' = Pk$.\nThen,\n$$x = \\frac{L}{\\sqrt{P}}$$\n$$y = L\\sqrt{P}$$\n\nWe, introduce three terms\n\n- $V_0$, value of initial holdings in terms of Y\n- $V_1$, value when kept in pool\n- $V_{held}$, value when held\n\n$$V_0 = y * 1 + x * P = 2L\\sqrt{P}$$\n\n$$V_1 = 2L\\sqrt{P'} = 2L\\sqrt{Pk}$$\n$$V_{held} = y + xP' = L\\sqrt{P}(1+k)$$\n$$IL(k) = \\frac{V_1 - V_{held}}{V_{held}} = \\frac{L\\sqrt{P}(2\\sqrt{k} - 1 - k)}{L\\sqrt{P}(1 + k)} = \\frac{2\\sqrt{k}}{1+k} - 1$$\n\n## Uniswap V3 Pool Maths\n\nUniswap V3 pools are different from V2 as the liquidity is not uniformly distributed from $0$ to $\\infty$, but each position functions as a separate CFMM curve.\n\n![Uniswap V3 Concetrated Liquidity](thoughts/images/UniswapV3Liquidty.png)\n\nFor an $xy=k$ curve, let $P_a$ and $P_b$ be the price range in which liquidity is deployed, then Real Reserves:\n\n$$(x + x_{offset})(y + y_{offset}) = L^2$$\n\nwhere, $x_{offset}$ and $y_{offset}$ is the point A and B at which lines $x=ky$ touch the liquidity curve. $P_b$ \u003e $P_a$, i.e. steeper the slope more is the price. Since, liquidity outside this position is irrelevant, the real reserves are obtained shifting the curve by the offsets.\n\n![Uniswap V3 Virtual Reserves](thoughts/images/UniswapV3Reserves.png)\n\nEquation of Real Reserves becomes:\n$$(x + x_{offset})(y + y_{offset}) = L^2$$\n$$(x + \\frac{L}{\\sqrt{P_b}})(y + L\\sqrt{P_a}) = L^2$$\n\nThis can be divided into three parts:\n\n1. Current Price, $P \u003c= P_a$\n\nWhen price \u003c $P_a$, all of the liquidity is in asset X, then\n\n$$(x + \\frac{L}{\\sqrt{P_b}})L\\sqrt{P_a} = L^2$$\n$$x = L\\frac{\\sqrt{P_b} - \\sqrt{P_a}}{\\sqrt{P_a}\\sqrt{P_b}}$$\n\n2. $P \u003e= P_b$\n\nWhen price \u003e $P_b$, all of the liquidity is in asset Y, then\n\n$$y = L(\\sqrt{P_b} - \\sqrt{P_a})$$\n\n3. $P_a \u003c P \u003c P_b$\n\nAssume that the price moves from P_a to P, then the amount of asset Y contributing to liquidity should be equal to amount of asset X contributing to liquidity when moving from P_b to P.\n\n$$L_x (P_b, P) = L_y(P, P_a)$$\n$$x\\frac{\\sqrt{P}\\sqrt{P_b}}{\\sqrt{P_b} - \\sqrt{P}} = \\frac{y}{\\sqrt{P} - \\sqrt{P_a}}$$\n$$x = L\\frac{\\sqrt{P_b} - \\sqrt{P}}{\\sqrt{P}\\sqrt{P_b}}$$\n$$y = L(\\sqrt{P} - \\sqrt{P_a})$$\n\n## Core\n\nUniswap's Core contracts functionality can be divided into three main components:\n\n1. Price and Liquidity\n2. TWAP Oracle\n3. Fees\n\nMain building blocks for these functionality is through `ticks` and `positions`.\n\n### Ticks\n\nA tick in terms of price is represented as:\n$$i_c = \\lfloor{\\log_{\\sqrt{1.001}}\\sqrt{P}}\\rfloor$$\n\nIn Uniswap V2, price space was continuous as the liquidity was divided across the whole space i.e. $[0, \\infty]$. V3 introduced the concept of concentrated liquidity in the form of ticks i.e. now, the price is divided discretely such that 1 tick represents 1 basis points (0.01% price change).\n\n```solidity\n// info stored for each initialized individual tick\nstruct Info {\n    // the total position liquidity that references this tick\n    uint128 liquidityGross;\n    // amount of net liquidity added (subtracted) when tick is crossed from left to right (right to left),\n    int128 liquidityNet;\n    // fee growth per unit of liquidity on the _other_ side of this tick (relative to the current tick)\n    // only has relative meaning, not absolute â€” the value depends on when the tick is initialized\n    uint256 feeGrowthOutside0X128;\n    uint256 feeGrowthOutside1X128;\n    // the cumulative tick value on the other side of the tick\n    int56 tickCumulativeOutside;\n    // the seconds per unit of liquidity on the _other_ side of this tick (relative to the current tick)\n    // only has relative meaning, not absolute â€” the value depends on when the tick is initialized\n    uint160 secondsPerLiquidityOutsideX128;\n    // the seconds spent on the other side of the tick (relative to the current tick)\n    // only has relative meaning, not absolute â€” the value depends on when the tick is initialized\n    uint32 secondsOutside;\n    // true iff the tick is initialized, i.e. the value is exactly equivalent to the expression liquidityGross != 0\n    // these 8 bits are set to prevent fresh sstores when crossing newly initialized ticks\n    bool initialized;\n}\n```\n\n### Position\n\nPosition refers to the liquidity earned after submiting tokens to the pool and measures fees earned over that position.\n\n```solidity\nstruct Info {\n  uint128 liquidity;\n\n  // fee growth after last update\n  uint256 feeGrowthInside0LastX128;\n  uint256 feeGrowthInside1LastX128;\n\n  // fees owed to position in tokens0/1\n  uint128 tokensOwed0;\n  uint128 tokensOwed1;\n}\n```\n\n### Fee Growth\n\nEach position update require updates in fees inside that range.\n\n$$\n\\begin{equation}\n  f_r = f_g - f_b(i_l) - f_a(i_u)\n\\end{equation}\n$$\n\n$$\n\\begin{equation}\n  f_a(i) =\n  \\begin{aligned}\n    \\begin{cases}\n      f_g - f_o(i) \u0026 {i_c \\ge i} \\\\\n      f_o(i) \u0026 i_c \u003c i\n    \\end{cases}\n  \\end{aligned}\n\\end{equation}\n$$\n\n$$\n\\begin{equation}\n  f_b(i) =\n  \\begin{aligned}\n    \\begin{cases}\n      f_o(i) \u0026 {i_c \\ge i} \\\\\n      f_g - f_o(i) \u0026 i_c \u003c i\n    \\end{cases}\n  \\end{aligned}\n\\end{equation}\n$$\n\n### Mint or Burn Flow\n\n```solidity\nmint(address recipient, int24 tickLower, int24 tickUpper, uint128 amount, bytes calldata data)\n\nburn(int24 tickLower, int24 tickUpper, uint128 amount)\n```\n\n1. Modify position\n   1. check ticks\n   2. update position\n      1. get position\n      2. if `liquidityDelta != 0`, `observeSingle`\n      3. update lower and upper tick with data\n      4. if either flipped, update ticks bitmap\n      5. get `feeGrowthInside{0,1}X128`\n      6. update position\n   3. if `liquidityDelta != 0`, calculate `amount0` and `amount1` according to tick range\n      1. `currentTick \u003c tickLower`: all liquidity in token0\n      2. `currentTick \u003e tickUpper`: all liquidity in token1\n      3. else, write oracle entry, calculate `amount0` and `amount1`\n2. call mintcallback or burn callback\n3. update balances if burn or check balances if mint\n\n## Oracles\n\nUniswap V2 `cumulativePrices` served as Oracles. Now, V3 introduces historical pricing\n\n## Resources and Acknowledgements\n\n- [Uniswap docs](https://docs.uniswap.org)\n- [Uniswap V3 LP Rekt](https://rekt.news/uniswap-v3-lp-rekt/)\n- [Uniswap v3 liquidity formula explained](https://atiselsts.medium.com/uniswap-v3-liquidity-formula-explained-de8bd42afc3c)\n- [Liquidty Maths in Uniswap V3](https://atiselsts.github.io/pdfs/uniswap-v3-liquidity-math.pdf)\n- [Uniswap V3 math Desmos](https://www.desmos.com/calculator/q2kxfue441)\n- [Technical Analysis of Uniswap V3](https://credmark.com/blog/a-technical-analysis-of-uniswap-v3)\n- [Impermanent Loss On Uniswap V3](https://medium.com/auditless/impermanent-loss-in-uniswap-v3-6c7161d3b445)\n- [Liquidity Providing in Uniswap v3](https://reuptake.medium.com/liquidity-providing-in-uniswap-v3-49bf3a0bd2ec)\n- [Uniswap V3 LP tokens as Perp](https://lambert-guillaume.medium.com/uniswap-v3-lp-tokens-as-perpetual-put-and-call-options-5b66219db827)\n\n### TWAP Oracles\n\n- [Uniswap Oracle attack simulator](https://blog.euler.finance/uniswap-oracle-attack-simulator-42d18adf65af)\n- [Uniswap V3 TWAP Oracle](https://medium.com/blockchain-development-notes/a-guide-on-uniswap-v3-twap-oracle-2aa74a4a97c5)\n\n### Academics\n\n- [Impermanent Loss In Uniswap V3](https://arxiv.org/abs/2111.09192)\n\n### Other Resources\n\n- [Awesome Uniswap V3](https://github.com/GammaStrategies/awesome-uniswap-v3)\n- [@Sabnock's Uniswap Resources](https://github.com/Sabnock01/uniswap-resources)\n","lastmodified":"2022-09-20T06:01:26.630238632Z","tags":null},"/thoughts/fixed-rate-protocols":{"title":"Fixed Income Protocols","content":"\nDeFi's next wave of protocols has come through fixed income protocols. I will go deep into yield curves based protocols i.e. [Yield](https://yield.is), [Notional](https://notional.finance).\n\n## Yield Protocol\n\nYield introduced *yTokens* i.e. `Yield Tokens` similar to compound's *cTokens* which essentially behaves as zero-coupon bonds expiring at a future date and can be redeemed 1-on-1 for the underlying asset.\n\n*yTokens* can be building blocks that can be used to make many other interesting products. Market price of *yTokens* can be used as interest rate oracle. Each yToken has its own interest rate over the period to expiration date which can be used by many other protocols to settle on-chain interest rate derivatives.\n\n*yTokens* differ from each other in four aspects:\n\n1. Underlying Asset\n2. Collateral Asset\n3. Collateralization requirement\n4. Expiration Time\n\n## Actors\n\n### Borrowers\n\nBorrowers is when actor opens a vault, takes out *yToken* and sells it. It is essentially shorting the underlying asset or longing the collateral asset.\n\n### Lenders\n\nBuying yTokens are similar to lending the underlying asset in which the holder of yToken is earning an interest on the underlying asset in the form of the discount which it gets when buying the yTokens.\n\n## Settlement\n\nyTokens can be construcuted using 3 main principals.\n\n### Cash settlement\n\nCash Settlement is paid in the collateral asset, which implies that it depends on a dependent price oracle that determines the price of underlying asset in terms of collateral asset.\n\nAt the moment of maturity, anyone can call the contract to trigger *settlement*, that redeems the *yTokens* for its equivalent value in collateral asset. After the moment of settlement, *yTokens* begin to track the price of collateral asset rather than the price of underlying asset but can only be redeemed at the price of settlement.\n\nThis mechanism has an advantage that it can support any asset and not just ERC20 assets as it just needs a price oracle to compare the price of yTokens with the collateral asset.\n\n### Physical settlement through auctions\n\nAt the time of minting a yToken, it is backed using the collateral asset. Minting the tokens adds to the vault's owner debt which shouldn't be less than the value of the collateral asset plus some required margin.\n\nWhen a target asset is also an ERC20 token, its settlement can be triggered physically i.e. holders get paid in underlying asset rather than collateral assets through auctions.\n\nGradual dutch auctions are held to sell the collateral for the underlying asset. Remaining collateral is returned back to the vault owner and underlying tokens earned during the auction is ditributed among *yToken* holders.\nIf auction is not completed successfully, collateral asset is distributed amont the holders along with physical assets.\n\nAdvantage over cash settlement is that after the auction is successfully done, each *yToken* is backed equally with the underlying asset rather than some collateral asset. Holders can redeem the underlying asset (but doesn't earn yield on it).\n\n### Synthetics Settlement\n\nWhen the target asset itself is a collateralized synthetic asset like DAI, *yToken* uses token's own issuance mechanism as settlement.\n\nIn case of DAI, if yDAI backed with ETH as collateral matures, the protocol creates a vault in MakerDAO with ETH as collateral. When yDAI holders come to redeem, it borrows DAI from Maker and pay to the yDAI holders. Essentialy fixed rate position in yTokens turns into variable rate debt position at the time of maturity for these synthetic assets. yDAI holders need to pay the interest for their debt position and can earn DAI savings rate as well.\n\nAdvantage is that borrowers' and lenders' position is not settled and have the option to keep it open with the synthetic token's own mechanisms.\n\n## Interest Rate oracle\n\n*yTokens's* price in itself throughout the period until maturity can be treated as an interest rate oracle as the *yTokens* price floats freely depending on the supply and demand.\n\n$$Y = (\\frac{F}{P})^{\\frac{1}{T}} - 1$$\n\n---\n\n## YieldSpace AMM\n\nA new invariant based AMM introduced to trade *fyTokens* introduced in yield paper which incorporates time into the AMM equation.\n\n$$x^{1-t}+y^{1-t} = k$$\n\n$y$ = reserves of *fyToken*,\n\n$x$ = reserves of underlying token.\n\n$t$ = time to maturity\n\n---\n\n![yieldspace curve](thoughts/images/yieldspace_curve.png)\n\nThis formula works as constant sum protocol when $t-\u003e0$, and constant product formula when $t-\u003e1$.\n\nThis formula is defined in the yield space rather than the price space as designed in previous AMM formulas such that marginal interest rate of fyTokens at any time is equal to ratio of fyToken reserve to underlying token reserve minus 1.\n\n$$r = \\frac{y}{x} - 1$$\n\nThis formula does not have any time component, thus ensures that marginal interest rate remains proportional to fyToken and underlying token reserves at any point in time. This implies that as the allocation of fyToken in the pool increases or underlying token decreases so does the interest rate and buying pressure arises, and vice versa.\n\n## Why not other invariants\n\n1. Constant sum invariant only works for assets of similar value, and fyToken generally is priced at a discount until maturity date.\n2. Constant product formula includes liquidity at whole price spectrum but when the fyToken approaches maturity, its price tend to be similar to underlying token and thus the liquidity at other price points are wasted and larger trades have significant impact on interest rates.\n3. Curve's stableswap equation doesn't let it modify $\\chi$ to account for variation in interest rates due to time to maturity.\n\n## Properties\n\n$$x^{1-t}+y^{1-t} = x_{start}^{1-t} + y_{start}^{1-t}$$\n\nMarginal price for a given $x_{start}$, $y_{start}$, and $t$ is given by the formula:\n\n$$(\\frac{y}{x})^t = (\\frac{(x_{start}^{1-t} + y_{start}^{1-t} - x^{1-t})^\\frac{1}{1-t}}{x})^t$$\n\n![token price vs reserves](thoughts/images/dai_price_vs_dai_reserves.png)\n\nLooking at interest rates,\n\n![interest rate vs dai reserves](thoughts/images/interest_rate_vs_dai_reserves.png)\n$$\\frac{y}{x} - 1 = \\frac{(x_{start}^{1-t} + y_{start}^{1-t} - x^{1-t})^\\frac{1}{1-t}}{x} - 1$$\n\n## Fees\n\nLP are incentivised to provide liquidity using the fees that they earn. Since, constant sum power formula is defined in yield space and not price space, it's not meaningful to impose fees on price and rather on interest rates i.e. any buyer of fyToken should get lesser interest rates or higher buy price.\n\nThus, the fee formula modifies the interest rate by adding a variable $g \u003c 1$ to change interest rates.\n\n$$r = (\\frac{y}{x})^g - 1$$\n\n\u003e Note that this formula is used for buying fyTokens, $\\frac{1}{g}$ is used when selling fyTokens.\n\nThus, the new AMM formula becomes\n\n$$x^{1-gt}+y^{1-gt} = k$$\n\n## Capital Efficiency\n\nOriginal protocol allows user to mint 1 fyToken in exchange of 1 underlying token and there is no real incentive to buy a fyToken above the underlying token price. Thus, the pool always checks at the end of every trade that price of 1 fyToken is not greater than 1 underlying token or reserves of fyToken is greater underlying. Thus, Some portion of fyToken reserves in the pool is always inaccessible. Example can be when pool is first initialized, the equal fyToken in the pool is never utilised as the remaining fyToken can't be sold.\n\nSo, the capital efficieny of the pool is improved by making the excess fyToken's reserves `virtual`. LPs don't need to contribute these access reserves. Pool uses liquidity tokens `s` as the virtual fyTokens reserves. Whenever a trade occurs, `virtual` tokens are added to actual reserves to calculate the appropriate amount but whenver liquidity is added, only the real reserves are used to calculate fyTokens in proportion to the actual fyToken in pool.\n\n## Resources\n\n- [Yield Paper](https://research.paradigm.xyz/Yield.pdf)\n- [Yieldspace paper](https://yield.is/YieldSpace.pdf)\n- [Element finance paper](https://paper.element.fi//)\n- [Sense](sense-finance.md)\n- [Messari's Fixed Income Protocol](https://messari.io/article/fixed-income-protocols-the-next-wave-of-defi-innovation)\n- [Designing Yield Tokens](https://medium.com/sensefinance/designing-yield-tokens-d20c34d96f56)\n- [Swivel's cash flow instruments Pt.1](https://swivel.substack.com/p/cash-flow-instruments-pt-1-history?s=r)\n- [Defization of fixed income products](https://medium.com/coinmonks/the-defization-of-fixed-income-products-7e72ed4f57b1)\n- [Defixed income](https://medium.com/@exactly_finance/defixed-income-101-948976c0e2c6)\n- [Notional](https://medium.com/coinmonks/notional-the-alpha-of-fixed-income-defi-products-a5637d2092b5)\n- [](https://medium.com/finoa-banking/turning-proof-of-stake-yield-into-fixed-income-products-7de8a73097ac)\n- [Fixed Income Protocols](https://medium.com/gamma-point-capital/fixed-income-protocols-the-next-wave-of-defi-innovation-69215be82b4e)\n\n\n## Questions\n\n- What are fixed yield rate protocols?\n- different types of protocols currently\n\nmainly three types: tranches, zero-coupon and stripping. Sense follows stripping architecture\n\n- what are tranches based and zero-coupon based?\n\ntranches are where users provide their assets and protocols invests in different strategies on the basis of risks of the tranche. More risk assosciated. Each protocol has their own set of safety backstops to stop protocol from being insolvent.\n\nZero coupon based protocols essentialy turn the asset into a bond which is traded at a discount and is exchangeable 1-1 at maturity.\n\nSense follows stripping architecture that allows it to strip target into PT and YT. Note that target in Sense can be yield bearing assets. This yield is given then to YTs.\n\n- What are yield or notional doing?\n\nyield issues zero-coupon bonds taking collateral and giving fyTokens. susceptible to liquidations in volatile markets.\n\n- what is 88mph or barnbridge doing?\n\n88mph/barnbridge uses lending market protocols like compound, aave to provide fixed yields to deposited assets. These fixed interest rate models are determined by governance. These protocols are prone to drop in interest rate offered by the variable markets after the deposit. They offset this by issuing Floating rate bonds to users for the extra yield. This model is hard to scale, requires governance at every step, not risk-free for users as they can't exit at will because the firb are issued at fixed terms.\n\n- Why yield stripping and not others?\n\ntranches not safe, and zero-coupon bonds mainly use underlying assets which does not take into account the yield. Stripping applications takes a yield bearing assets and gives the user security against their principal in PTs and yields in YTs. So, its just more safer and transparent for users, better abstractability and flexibilty for devs and users as they can plug these PT or YT further.\n\n- Sense space?\n- yieldspace pools\n\nmakes sense to account for implied rate and liquidity to be spread around interest rate rather than the price as price there is function of rate itself. space better as target is deposited, no IL, yield goes to LPs.\n\n- How are PTs and YTs priced?\n\nStripping protocols follows the invariant that PTs + YTs at any point = Target. At the time of series creation, YTs are the claim to the yield and PTs trade at discount which is Target - YTs. As maturity approaches, PTs tend towards the price of target 1 on 1.\n\nPTs are priced according to formula $(\\frac{y}{x})^{\\frac{1}{t}}$, where x and y are reserves in pool.\n\nYTs are priced according to the yield payments that they're going to receive till maturity. So, if 4 yield payments of $0.1, then $0.4 is their price.\n\n- What is a series?\n\nseries is a specific set of PTs and YTs of a target with specific maturity and specific adapter.\n\n- list all common sc attack patterns?\n\nunverified calls, dos, delegatecalls, signature malleability, re-entrancy, arithmetic over/underflows, randomisation in evm, tx.origin, selfdestruct\n\n- compound, aave, fuse?\n\n- what is your thinking when designing some project?\n\ndepends on the project,\n\n1. swap\n2. lend\n\nthen thinking about actors and their actions, then modules, external interactions\n\nuniswap like structure i.e. core and periphery. Anybody can directly build on core and periphery is used for normal user interaction with the protocol.\n\n- How do you guys take an idea from different phases to mainnet?\n- do you use other tools to test your smart contracts like slither, echidna ?\n-","lastmodified":"2022-09-20T06:01:26.634238639Z","tags":null},"/thoughts/nomad-xyz":{"title":"Nomad","content":"\nProtocol for cross-chain communication. Follows **optimistic** design inspired from _Optimistic Rollups_. Nomad's design aims to solve the interoperability trilemma famously coined by Connext but introduces a new component, `latency`.\n\n## Design\n\nArchitectural design is divided into two main components:\n\n- On-chain components\n  - Home\n  - Replica\n- Off-chain components\n  - Updater\n  - Relayer\n  - Watcher\n  - Processor\n\n## Optimistic Flow\n\nNomad works with both of these components to facilitate communication between any number of chains that support user-defined computations. It takes use of _sparse merkle trees_ as data structure to pass message between the chains.\n\nThere is a source domain with `Home` contract and a destination ~~chain~~ domain with the `Replica` contract. `Home` is reponsible for generating the message on the source domain and `Replica` on the destination domain keeps a copy of the tree which gets updated when new messages are received from the source domain.\n\n\u003e Note: We'll use `domain` here instead of `chain` as Nomad is a base layer that can be used with any chains, rollups, etc.\n\nHow these messages gets passed securely is handled by the off-chain components which helps in ease of implementation and reducing the cost of these transfers by 80%. The `updater` component polls messages from the `Home` contract in the form of a merkle tree and attests it. It is then sent to the destination chain by the `Relayer`. There, it waits for some time before being added in the Replica contract which holds the current root. Since, `updater` can attest fraudulent messages, the timeout gives anyone the chance to prove the fraud which results in bond slashing of updater and all the attestations being marked as invalid.\n\nSince the messages are just a merkle tree being committed to newer messages, it can be easily rolled back. The process of timeout and `Watchers` submitting a fraud proof is done on the receiving chain because a `Relayer` doesn't know about messages at all, it's job is just to relay whatever message it receives from source chain. These fraud can be proven back to the source chain as that is the original `Source of Truth`, which slashes the `Updater` bonds.\n\nNomad rather than handling globally verified fraud proofs on the sending chain, allows fraudulent messages to pass through as then these frauds become public due to the timeout at the receiving chains. These can then easily be proven to the source chain which becomes the source of truth that these fraudulent messages where in fact, passed by the `Updater`.\n\n## Components\n\n### On-Chain Components\n\n#### `Home`\n\n- Used by other contracts to send messages using `send message` API\n- enfore message format\n- updates root by committing messages\n- maintains queue of tree roots\n- slashes `Updater` bonds\n  - Double update proofs\n  - Improper update proofs\n\n#### `Replica`\n\n- maintains queue of pending updates\n- add to new tree root after timeout elapses\n- accepts fraud proofs to validate messages\n- ensure processing of messages in proper order\n- sends messages to end recipients\n\n### Off-Chain Components\n\n#### `Updater`\n\n- polls home for new updates\n- signs or attests to new updates\n- publish to home chain\n\n#### `Relayer`\n\nrelays updates to new\n\n- Observes home to check for new updates\n- forwards the signed updates to one or more replicas\n- Observes replicas for timeout passed updates and updates relayer current root\n\n#### `Watcher`\n\nProvides security to the protocol\n\n- Submits Double/Invalid update proof\n- Observes home, to check the interaction of updater's with the Home contract to check for any malicious attestations\n- Observes replicas, so that updater doesn't directly go to replica\n\n#### `Processor`\n\nprocesses pending updates\n\n- maintains the old tree with all the details\n- creates proof for new updates\n- send proven messages to end recipients\n\n## Frauds\n\nCurrently, there are two types of fraud that can occur in the system.\n\n1. ### Improper Update\n\nOccurs when an `Updater` attests to a fake root that was not in the `Home` root's queue. Updater purpose is to send fake messages to the destination chain.\n\nThis can be easily proven by the `Watcher` by submitting the fake root and Updater sig to Home, eventually slashing Updater's bonds or at worst halting the transfers to destination chain.\n\n2. ### Double Update\n\nAn `Updater` can attest two identical roots, i.e. the roots share same sig in order to double spend the receiving chain. This gets detected by `Watcher` as the duplicate root submitted by Updater is not the part of the queue as it's already sent to the destination chain.\n\n## Token Bridge xApp Example\n\n**Source**: Chain A\n\n**Destination**: Chain B\n\n**Local Contract**: Contract on same chain\n\n**Remote Contract**: Contract on other chain\n\n- **Source**\n\n  - User approve tokens to local `BridgeRouter`\n    - If native token, held in escrow and sent to local `Home`\n    - If non-native, token burned as the contract is deployed by `BridgeRouter`\n  - Message constructed by local `BridgeRouter` to send tokens to `Destination` on `Remote BridgeRouter`\n    - It keeps mapping of bridge routers on other chains, to send message to desired receiver.\n  - enqueues message on `Home`\n\n- Off-Chain\n\n  - Updater attests to the root\n  - relayer forwards it to `Remote Replica`\n  - processor creates proof\n\n- **Destination**\n  - `Replica` processes message after timeout ends and sends message to `BridgeRouter`\n  - `BridgeRouter` verifies that it was sent by `Source BridgeRouter` as it keeps mapping of `BridgeRouter` of other chains\n  - Looks for ERC20 token in registry\n  - Sends token to recipient\n    - If native, send from tokens held in escrow\n    - If non-native, mints new tokens as the representative token contract is deployed by the `BridgeRouter`\n\n## Questions\n\n1. Why is an `Updater` called an `Updater` even tho its job is more like a validator?\n\n2. Can a `Relayer` send fraudulent updates? What if it does, and who gets slashed in that case?\n\nNo, it can't as it's job is just to relay whatever updates it polls to receiving chain.\n\n4. What are the future plans of tackling this optimistic timeout delay?\n\nRight now, this is more of a feature than a disadvantage as it makes system more robust and for implementation ease as well. Need more idea about future plans. Moreover, connext plays out an important role here to partner with Nomad and reduce this to nearly 2 mins.\n\n5. Does this `30 min` delay quantified on a basis? How is it chosen? Can it be variable on the basis of watcher numbers or some other factors? or is it fixed?\n\nResearch: https://medium.com/offchainlabs/fighting-censorship-attacks-on-smart-contracts-c026a7c0ff02\n\n6. How does a bridge handles fork on a sending chain? Does the updates get rolled back?\n\nMaybe here the timeout delay plays out as an advantage, if a fork occurs on a sending chain, the `Relayer` can mark update as invalid and it is no longer processed by `Processor`.\n\n7. Nomad assumes security on the presence of even 1 watcher, doesn't that create centralization risk? Can that 1 watcher be the same updater?\n\n8. Can Nomad leverage ETH consensus mechanisms like RANDAO to pseudo-randomly select updators and watchers?\n\n## Links\n\n- [Nomad Docs](https://docs.nomad.xyz)\n- [Optimistic Brides](https://blog.connext.network/optimistic-bridges-fb800dc7b0e0)\n- [The Cheater Checking Problem: Why the Verifierâ€™s Dilemma is Harder Than You Think](https://medium.com/offchainlabs/the-cheater-checking-problem-why-the-verifiers-dilemma-is-harder-than-you-think-9c7156505ca1)\n","lastmodified":"2022-09-20T06:01:26.634238639Z","tags":null}}