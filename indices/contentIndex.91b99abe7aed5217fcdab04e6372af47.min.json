{"/":{"title":"ðŸ—¡ lonerapier.xyz","content":"\n","lastmodified":"2022-09-02T07:02:55.400678771Z","tags":null},"/posts/ECC":{"title":"","content":"# ECC\n\n## Resources\n\n[Group Theory | Brilliant Math \u0026 Science Wiki](https://brilliant.org/wiki/group-theory-introduction/)\n\n[Picking a Base Point in ECC](https://medium.com/asecuritysite-when-bob-met-alice/picking-a-base-point-in-ecc-8d7b852b88a6)\n\n[Whatâ€™s The Order in ECC?](https://medium.com/asecuritysite-when-bob-met-alice/whats-the-order-in-ecc-ac8a8d5439e8)\n\n- [https://github.com/ethereumbook/ethereumbook/blob/develop/04keys-addresses.asciidoc#elliptic_curve](https://github.com/ethereumbook/ethereumbook/blob/develop/04keys-addresses.asciidoc#elliptic_curve)\n[Secp256k1 | River Glossary](https://river.com/learn/terms/s/secp256k1/)\n\n[Discrete Log Problem (DLP) | River Glossary](https://river.com/learn/terms/d/discrete-log-problem-dlp/)\n\n[Elliptic curves secp256k1 and secp256r1](https://www.johndcook.com/blog/2018/08/21/a-tale-of-two-elliptic-curves/)\n\n[Why did Satoshi decide to use secp256k1 instead of secp256r1? - DappWorks](https://dappworks.com/why-did-satoshi-decide-to-use-secp256k1-instead-of-secp256r1/)\n\n[Exploring Elliptic Curve Pairings](https://medium.com/@VitalikButerin/exploring-elliptic-curve-pairings-c73c1864e627)\n\n## Elliptic Curve Cryptography\n\n$$y^2 = x^3 + ax^2 + bx + c$$\n\nsecp256k1: used by Bitcoin and Ethereum to implement public key cryptography. Elliptic curve over a field $z_p$ where $p$ is a 256-bit prime.\n\nECDSA: Elliptic Curve Digital Signature Algorithm\n\nPublic key cryptography uses this method to calculate public keys which is a point on ECC curve.\n\n$$K = (k * G) \\% p$$\n\n- K = 512-bit public key\n- k = 256-bit randomly generated private key\n- G = base point on the curve\n- p = prime number\n\nTake a base point $G$, add it $n$ (private key) times to make $nG (\\% p)$ (public key).\n\n\u003e **Note**: addition here means addition in elliptic curve and not addition in field of integers mod p.\n\nOrder of a base point is when keys generated using this point starts to form a cycle. Max number of points on the curve.\n\nThus, choosing a good base point is necessary in any public key generation curves.\n\nsecp256k1:\n\n```other\nx = 0x79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798\ny = 0x483ADA7726A3C4655DA4FBFC0E1108A8FD17B448A68554199C47D08FFB10D4B8\np = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F\n```\n\nThe order is:\n\n```other\nN = FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141\n```\n\nEthereum public keys are serialization of 130 hex characters\n\n```other\n04 + x-coord (64) + y-coord (64)\n```\n\n\u003e 04 is prefixed as it is used to define uncompressed point on the ECC.\n\nEthereum addresses are hexadecimal numbers, identifiers derived from the last 20 bytes of the Keccak256 hash of the public key.\n\n## EIP55\n\nMixed capitalisation of letters in the address\n\nTake keccak256 hash of the address, capitalize character if hex digit of hash is greater than 8.\n\n## Discrete Log Problem (DLP)\n\ndescribes that there are currently no known method for calculating point division on an elliptic curve.\n\n### Why Discrete logarithm?\n\nECC is significant because solving $k*G$ is trivial but obtaining $k$ from product $k*G$ is not.\n\nk*G can be obtained using Fast-Exponentiation algorithm but solving for k requires computing discrete logarithms.\n\n## Security\n\nBig-O Notation of discrete logarithm problem is $O(\\sqrt{n})$.\n\nBase point G, is chosen to be closer to $2^{256}$ and thus is in the order of 256.\n\nSo, $\\sqrt{256} = 128$ bits level of security is provided by curves like secp256k1.\n\n## secp256k1 v/s secp256r1\n\nsecp256k1 is a Koblitz curve defined in a characteristic 2 finite field while secp256r1 is a prime field curve.\n\nNot going into details as to what a characteristic 2 finite field is, we can specify secp256r1 as a pseudo-randomised curve and secp256k1 as completely random curve which canâ€™t be solved using discrete logarithm problem **yet**.\n\n## BLS Signatures\n\n\n## To-Read\n\n1. [https://medium.com/@VitalikButerin/exploring-elliptic-curve-pairings-c73c1864e627](https://medium.com/@VitalikButerin/exploring-elliptic-curve-pairings-c73c1864e627)\n2. [https://eth2book.info/altair/part2/building_blocks/signatures](https://eth2book.info/altair/part2/building_blocks/signatures)","lastmodified":"2022-09-02T07:02:55.400678771Z","tags":null},"/posts/Optimistic-Rollups":{"title":"","content":"# Optimistic Rollups\n\n## Links\n\n[(Almost) Everything you need to know about Optimistic Rollup](https://research.paradigm.xyz/rollups)\n\n[The Cheater Checking Problem: Why the Verifierâ€™s Dilemma is Harder Than You Think](https://medium.com/offchainlabs/the-cheater-checking-problem-why-the-verifiers-dilemma-is-harder-than-you-think-9c7156505ca1)\n\n## Asserter/Checker Problem\n\n- Asserter makes a claim $A$, checker checks the claim for cost $C$ and gets R as reward, if successful.\n- If Asserter cheats without getting caught, Checker loses $L$ in the form of loss of items of value.\n- Two main threats to worry about: Laziness and Bribery\n- Bribery: Asserter bribes Checker more than the reward $R$. Prevent this by large bond by Asserter so that bribe canâ€™t be bigger than the reward $R$.\n- Laziness: Checker does not check intentionally.\n- If we assume, asserter cheats with prob. X, then\ncheckerâ€™s utility comes as:\n\n\u003e $-X*L$, if checker doesnâ€™t\n\u003e\n\u003e $R*X-C$, if checker checks\n\n- So, checking is only worthwhile, if utility of checking \u003e not checking.\n\n\u003e $X \u003e C/(R+L)$\n\n- Thus, *asserter* can cheat with random prob \u003c required and not get caught.\n- This doesnâ€™t depend on how much *asserter* gains from cheating, as long as itâ€™s non-zero which is a bad result.\n- Even adding more *checkers* doesnâ€™t help, as the reward gets distributed which only reduces *checkerâ€™s* incentives.\n\nReason this is a problem:\n\n- *Asserter* controls the behaviour of the checker, as the utility of checker depends on asserterâ€™s prob.\n- Need to add an attention parameter in *checkerâ€™s* incentives where checker pre-computes *asserterâ€™s* claim off-chain beforehand and has to verify it on-chain time to time.\n- Two new parameters:\n\n\u003e $P$, fraction of time *checker's* will post response\n\u003e\n\u003e $A$, penalty in case *checker* gives wrong answer\n\n- New equation becomes,\n\n$$R*X-C$$\n\n$$-L*X-P*A$$\n\n- If $P*A \u003e C$, then checking is better than not checking\n- cost of checking is low\n\n\u003e Assume 1 assertion / 5 mins and $C = $0.001$ If P = 0.3%, checker will deposit $3.\ncost per assertion = $0.0003 =\u003e $0.01*0.3%\ninterest cost of locking = $0.0003\ntotal cost = $0.0006\n\n- Multiple checkers need to submit proofs differently thus, scaling to multiple checkers efficient.\n\n## Technical Details\n\nChecker: private key $k$, public key $g^k$\n\nHash fn: $H$\n\nComputation to solve: $f(x)$\n\nAsserter challenge: $(x, g^r)$\n\nChecker post on-chain iff $H(g^{rk}, f(x)) \u003c T$\n\n\u003e Note: Only checker and asserter knows $g^k$ and $r$, and $T$ requires $f(x)$\n\nChecker can guess $f(x)$ with prob. G, then multiply deposit with $1/1-G$\n\n- Asserter publishes f(x), can challenge checker's response while publishing r\n- Check the accusation and penalise checker, half the deposit to asserter\n- If asserter $f(x)$ incorrect, accusation reverted.\n- Each checker will have different prob of posting on-chain due to use of private key, thus canâ€™t copy others computation.\n- Asserter now instead of bribing checker, will try to mislead him into giving false information on-chain.\n","lastmodified":"2022-09-02T07:02:55.400678771Z","tags":null},"/posts/SoK":{"title":"","content":"# SoK\n\nLink: [https://eprint.iacr.org/2019/1128.pdf](https://eprint.iacr.org/2019/1128.pdf)\n\nAims to develop a guide for designing protocols bridging different types of blockchains (distributed ledgers).\n\nShows that CCC is impossible without **_third party._**\n\nPresents a framework keeping these trust assumptions in mind. Classifies current CCC protocols on the basis of framework.\n\n## Introduction\n\n- NB-AC (_Non-Blocking Atomic Commit_) is used in distributed databases to ensure that correct processes don't have to wait for crashed processes to recover.\n- Can be extrapolated to distributed ledgers by handling _byzantine failures._\n\n## Distributed Ledger Model\n\n- $X, Y$: Blockchains\n- $Lx$, $Ly$: ledgers with _states_ as dynamically evolving sequences of _transactions_\n- state of ledgers progresses in round _r._\n- $L^P[r]$: state of ledger _L_ at round _r_ after all txs till _r-1_, according to some party _P._\n- Consistency is defined by the system\n- ($TX$, $Lx^P[r]$): tx _TX_ is valid for _Lx_ at round _r_ according to _P._\n- $TX$ âˆˆ $L^P[r]$: TX is included in _L_ as position _r._\n- **Time** $L^P[t]$**:** ledger state at round r or time t.\n\n**Persistence**: $L^P[t] \u003c= L^Q[tâ€™]$, $L^P$ at time $t$ is prefix of $L^Q$ at time $t$â€™.\n\n**Liveness**: if tx $TX$ is included in ledger $L$ at time $t$, then it will appear in ledger at time $t$â€™.\n\n### CCC System Model\n\n- $P: TX_P, Q: TX_Q$: separate processes running on two different ledgers with txs\n- $P$ possesses a description $d_Q$ which characterises the transaction $TX_Q$, while $Q$ possesses $d_P$ which characterises $TX_P$\n- Thus, $P$ wants $Q$ to be written to $Ly$ and vice-versa.\n- $m_P, m_Q$: boolean error variables for malicious processes\n\n## Formalisation of correct CCC\n\nGoal: sync of P and Q such that Q is included iff P is included. For example, they can constitute an exchange of assets which must be completed atomically.\n\n**Effectiveness:** if both correct, then both will be included, otherwise none\n\n**Atomicity**: no outcome in which $TX_P$ included but $TX_Q$ not at time $t$â€™ or vice versa.\n\n**Timeliness**: If a process behaves correctly, $TX_P$ will be included and $Q$ will verify. It is a liveness property.\n\n## Generic CCC Protocol\n\n\u003e $u_x$: liveness delay\n\u003e\n\u003e $k_x$: depth parameter\n\n1. **Setup**: inherently done by both blockchains due to the properties defined above\n2. **Pre-Commit on X**: $P$ writes $TX_P$ to $L^P_X$ at time $t$ in round $r$. Due to persistence and liveness, all honest parties report TX_P as valid in $r+u_x+k_x$.\n3. **Verify**: Q verifies $TX_P$.\n4. **Commit on Y:** $Q$ writes $TX_Q$ to $L^Q_Y$ at time $t$â€™ in round $r$â€™.\n5. **Abort**: revert $TX_P$ on $Lx$ in case of verification failure or $Q$ fails\n\n![Image.png](https://res.craft.do/user/full/e83dd57b-d460-d205-2243-2f6ed8de496a/doc/2875A4D6-F00A-45A2-96EE-7222C31E634F/490D063A-EBE6-49DA-A5C7-D53342042837_2/q21xMyyBAkdRygr7FHp2PQr7J452ctL6JuxUysHHwccz/Image.png)\n\nCCC protocols follow two-phase commit design.\n\nPre-commit and commit on Y is executed in parallel following verification and abortion, if required.\n\n## Impossibility of CCC without TTP (Trusted Third Party)\n\nAnalogous to **_Fair Exchange_** Problem.\n\nTTP is basically any entity, be it individual or a committee that either confirms a tx has been successfully included or enforce correct behaviour of $Q$ on $Ly$.\n\nLemma 1: Let $M$ be a system model. Let $C$ be a protocol which solves $CCC$ in $M$. Then there exists a protocol $S$ which solves _Fair Exchange_ in $M$.\n\nSketch: to complete exchange, $TX_Q \\in  Ly$ and $TX_P \\in Lx$.\n\n- _effectiveness_ enforces correct transfer for correct behaviour.\n- Persistence and liveness enforce both txs to be eventually written to respective ledgers.\n- Atomicity $\u003c-\u003e$ Strong Fairness in Fair exchange\n\nSmart contracts or code based solutions can be used to write $TX_Q$ to $Y$, in this case consensus becomes TTP to execute this smart contract.\n\nTTP either becomes the process $P$ itself or another party which submits proof of $P$ inclusion to $Q$.\n\nMany other frameworks for designing a CCC protocol:\n\n- Incentivizing third party\n- Slashing the rewards\n- Optimistic\n\n## CCC Design Framework\n\nThree main types of trust model:\n\n- TTP\n- Synchrony\n- Hybrid\n\n### Pre-Commit Phase\n\n#### Model 1: TTP (Coordinators)\n\nCan participate in two ways:\n\n- Custody of Assets: taking control of protocol participant funds to enforce rules\n- Involvement in consensus: in case of smart contracts, when consensus participants are TTP\n\nCoordinator Implementations\n\n- External Custodians: Committee\n- Consensus Level Custodians (Consensus Committee)\n- External Escrows (Multisig Contracts)\n\n#### Model 2: Synchrony (Locking)\n\n- Locks based on hashes\n- Locks based on signatures\n- Timelock puzzles \u0026 Verifiable delay fns\n- Smart Contracts\n\n#### Model 3: Hybrid\n\nWatchtowers (Other external parties) to be used as fallback if one of the service fails or crashes\n\n### Verification Phase\n\nSame models but applied on verification part\n\n1. External Validators/Smart Contracts\n2. Direct Observation/Relay SCs (Using light clients)\n3. Hybrid using watchtowers\n\n### Abort Phase\n\n## Classification of Existing Protocols\n\n### Exchange Protocols\n\nAtomic exchange of digital goods: $x$ on Chain $X$ again $y$ on $Y$. Both parties pre-commit, then verify and abort in case of failure.\n\n#### Pre-Commit\n\nDone through atomic swaps\n\n- Both parties lock assets on-chain with identical release conditions. _Hashed Timelock contracts_ are the closest implementation of symmetric locks. Signature locks using _ECDSA_ are also used.\n- On turing-complete blockchains, atomic swaps can be handled through smart contracts which can verify the state of chain $Y$ (_chain relay_).\n- Hybrid: symmetric with TTP is used to solve usability challenges in atomic swaps.\n\n#### Verify\n\nDone through external validators in symmetric swaps or through chain relays in SPV based atomic swaps.\n\n#### Abort\n\nTimelocks are set up on assets for a pre-defined duration to prevent indefinite lock up in case of failures.\n\n### Migration Protocols\n\nMigrate the asset $x$ from chain $X$ using write locks on $x$ preventing further use on $X$ and creating a wrapped version of same asset on $Y$.\n\nFour main use cases of these protocols:\n\n- Wrapped version of assets between chains\n- communication b/w shards\n- sidechains\n- bootstrapping a new chain\n\n#### Pre-commit\n\nRelies on a single/committee based external custodian for TTP or through multisigs.\n\n**Sidechains**: same approach of depositing on chain $x$ controlled via multisigs which approve asset $y$ on chain $Y$.\n\n**Shards**: utilises the same security and consensus model as the main chain is same for all shards.\n\n_Bi-directional chain relays_ can also be used if both chains support smart contracts and thus, locking/minting of assets can be handled through these contracts.\n\n**Proof of Burn**: used for uni-directional flow as asset $x$ is burned on chain $X$.\n\n#### Verify\n\n- Chain relay contracts\n- Consensus committees to sign to verify pre-commit step.\n\n#### Abort\n\nMigration protocol doesnâ€™t have explicit abort phase.\n\n## CCC Challenges\n\n### Heterogeneous Models and Parameters Across Chains\n\n- Different parameters used by different chains\n- security models\n- consensus differences: consensus execution, finality\n\n### Cryptographic Primitives\n\ndifferent cryptographic algorithms for hash locks or signatures\n\nZK proofs may provide a workaround but increases complexity, communication costs.\n\n### Collateralization and Exchange Rates\n\nUsing collaterals to prevent malicious behaviour among custodians or TTPs, incentivising correct behaviour but different types and rates of collateral b/w different chains.\n\nDynamic Collateralization based on exchange rates among different blockchains\n\n#### Lack of Formal Security Analysis\n\n- Replay Attacks on state verification: if proofs are submitted multiple times either on the same chain or on different chains can lead to multiple spendings of assets.\n- Data availability: timely requirements of proofs and data, if not reached in time, leads to incorrect behaviour of process.\n\nNeed more research on this topic as current solution increases complexity and decreases efficiency.\n\n#### Lack of Formal Privacy Analysis\n\ndidnâ€™t understand perfectly\n\n### Upcoming Research\n\n- Interoperability chains: Cosmos and polkadot Layer 0 based ecosystems.\n- Light Clients: for better verification\n- Off-Chain Protocols\n  - Communication across off-chain channels\n  - Communication b/w on-chain and off-chain networks\n","lastmodified":"2022-09-02T07:02:55.400678771Z","tags":null},"/posts/eth-consensus":{"title":"","content":"# ETH 2.0\n\nELI5 understanding of ETH 2.0 specs\n\n**Safety**: gurantees that something bad never happen. Examples: Tendermint from Cosmos that uses BFT style consensus.\n\n**Liveness**: something good eventually occurs. Example: POW, Casper used by Ethereum.\n\n## **Why PoS**\n\nAn individual autonomy should always be greater than the power of any state. Cryptography solved this issue, by using ECC, individuals can now have a pair of keys that only he can access and thus, has the power to defend even state-level attacks.\n\nConsensus in blockchain is what drives the value of the network, and from where the network derives its value. No attacker should have incentives to attack the network for his own gain. PoW style networks are based on rewards where a consensus participant has almost nothing to lose in case the network is attacked. PoS solves this problem by allocating stakes to network particpants and imposing penalties in case of any malicious actors in the system. The ratio of rewards v/s penalties determines the incentives of consensus participants to behave honestly as penalties are directly proportional to number of wrong validations, if more validators behave maliciously, then slashing is higher.\n\n## Different types of PoS\n\n- Chain-Based PoS: pseudo-random validator assigned at each time slot to create new block behind a previous block\n- BFT-style PoS: (partially synchronous) randomly assigned validator proposes a block and canonical chain is assigned using a voting process on which each validator votes for the valid chain\n\n## **Proof Of Stake**\n\n- Stake ETH to become validator\n  - For each 32 ETH staked, a validator is activated. Anyone can stake any number of ETHs and activate and control validators and execute **validator clients**.\n  \u003e Validator clients has the functionality of following and reading the Beacon Chain. A validator client can make calls into the Beacon nodes.\n- Validator, responsible for adding blocks to the chain by verifying txs and policing blocks being added by other validators\n  - Earns by successfully adding blocks\n  - Staked eths slashed if illegal txs added\n- Save Energy as selected randomly and not competing\n- No need to mine, just validate blocks known as **Attesting**\n\n## **Phases**\n\n- Beacon Chain\n- Sharding\n- Execution\n\n## **Sharding**\n\n- Scaling nodes horizontally\n- At least 128 Validators randomly assigned to a shard where a new block will be added in each slot of an epoch i.e.,Â after 32 slots\n- ETH plans for 64 shards\n\n## **Beacon Chain**\n\n- Main functioning body in the blockchain, managing all the shards and the validators\n- Functions as heart of the chain\n- Creates **committee**, which are the validators used to validate a blockchain on which everyone verifies, stores and downloads\n\n## **Slots \u0026 Epochs**\n\n- Chain is divided into **slots** and **epochs**\n- **Slot** â†’ timeframe to propose and validate a new block\n  - In a time period pre-determined in a blockchain, 12 seconds in case of Ethereum, all shard blocks are added into the blockchain\n  - Slots can be empty in case a validator fails to **propose** the block or the committee fails to attest\n  - Genesis blocks added to both Beacon chain and shards at block 0\n- **Epochs** â†’ 32 slots comprises an epoch. \u003e 12 sec * 32 slots = 6.4 mins\n\n## **Crosslinks**\n\n- reference to shard blocks\n- basically the proof that a shard is valid\n- created at beacon chain for every successful block proposed by a shard\n- only after a crosslink does a validator get its reward\n\n## **Committee**\n\n- **Beacon chain** gets its name from the random numbers that it emits to the public\n- uses RANDAO process to randomly select a group of validators for an epoch to a shard to attest transactions in a block\n- crosslinks are made after attestation from validators of that slot\n- Every epoch, validators randomnly assigned to a slot which is then subdivided into committees.\n- Each committee is assigned a particular shard and they attempt to crosslink a shard block to Beacon chain head in order to gain rewards.\n- 64 shards, each assigned 128 validators per committee -\u003e Thus, has atleast 8192 validators\n\n### **Beacon Chain Checkpoints**\n\n![image](assets/Beacon-Chain-Checkpoints.jpeg)\n\nA `checkpoint` or an `epoch boundary` is the first block in an epoch. If no such block, it is the most recent preceding block.\n\n### Votes\n\n- **`LMD GHOST`**: validator vote for beacon chain head, i.e. what they believe beacon chain head is.\n- **`Casper FFG`**: When casting LMD GHOST vote, validators also vote for checkpoint in current epoch, called `target`. This also includes previous epoch checkpoint called `source`.\n\n## Finality\n\n\u003e `Supermajority vote`: which is made by 2/3 of the total **balance** of all validators.\n\n![image](assets/Beacon-Chain-Justification-and-Finalization.png)\n\nWhen an epoch checkpoint gets supermajority vote, it is said to be *justified*.\nAn epoch is *finalised* when it is justified and next epoch checkpoint gets justified.\nWhen a epoch checkpoint, i.e. slot gets finalised, all preceding blocks also gets finalised.\n\n- Finality is important as it gives gurantees to shards and ethereum parties regarding transactions.\n- Reduces complexity with cross-shard communications.\n\n## FLP Impossibility\n\n![image](assets/FLP-Impossibility.png)\n\nIn a distributed system, it is not possible to simultaneously have safetly, liveness and full asynchrony unless some unreasonable assumptions are made.\n\nEthereum uses both `LMD-GHOST` and `Casper FFG` as its protocol to justify and finalise blocks.\n\n**LMD-GHOST** preferes liveness over safety in the form that validator can attest to a chain head and keep producing blocks while **Casper** prefers safety over liveness such that a block is finalised only when it is justified and in a later epoch, majority of validators attest it again to finalise it. Once, a block is finalised, it is added forever in the chain.\n\nDue to **LMD-GHOST** prefering liveness over safety, there is a chance of reorgs. Capser FFG helps here as it prefers safety and decisions made under Casper is considered final. It has phases, in which nodes indicate they'd like to agree on something(justification), then agree that they've seen each other agreeing(finalisation).\n\n## **Questions**\n\n1. MEV in PoS\n2. Reorgs\n\n## **Checkpoints**\n\n1. [https://ethereum.org/en/developers/docs/consensus-mechanisms/pos/](https://ethereum.org/en/developers/docs/consensus-mechanisms/pos/)\n2. [eth2book.info](https://eth2book.info/altair/contents)\n3. [https://github.com/ethereum/annotated-spec/blob/master/phase1/beacon-chain.md#introduction](https://github.com/ethereum/annotated-spec/blob/master/phase1/beacon-chain.md#introduction)\n4. [https://ethos.dev/beacon-chain/](https://ethos.dev/beacon-chain/)\n5. [https://ethresear.ch/t/two-ways-to-do-cross-links/2074](https://ethresear.ch/t/two-ways-to-do-cross-links/2074)\n6. [https://vitalik.ca/general/2017/12/31/pos_faq.html](https://vitalik.ca/general/2017/12/31/pos_faq.html)\n7. [https://medium.com/codechain/safety-and-liveness-blockchain-in-the-point-of-view-of-flp-impossibility-182e33927ce6](https://medium.com/codechain/safety-and-liveness-blockchain-in-the-point-of-view-of-flp-impossibility-182e33927ce6)\n8. [https://medium.com/@VitalikButerin/a-proof-of-stake-design-philosophy-506585978d51](https://medium.com/@VitalikButerin/a-proof-of-stake-design-philosophy-506585978d51)\n9. [Ben Eddington blog](https://hackmd.io/@benjaminion/eth2_news/https%3A%2F%2Fhackmd.io%2F%40benjaminion%2Fwnie2_220311)\n10. [eth2book](https://eth2.incessant.ink/book/03__eth1/07__clients.html)\n11. https://arxiv.org/pdf/2203.01315.pdf\n12. [LMD GHOST and Casper FFG](https://blog.ethereum.org/2020/02/12/validated-staking-on-eth2-2-two-ghosts-in-a-trench-coat/)\n13. [https://blog.ethereum.org/2019/12/30/eth1x-files-state-of-stateless-ethereum/](https://blog.ethereum.org/2019/12/30/eth1x-files-state-of-stateless-ethereum/)\n14. [Understanding validator effective balance](https://www.attestant.io/posts/understanding-validator-effective-balancehttps://www.attestant.io/posts/understanding-validator-effective-balance/)\n15. [0xfoobar's Proof of Stake](https://0xfoobar.substack.com/p/ethereum-proof-of-stake)","lastmodified":"2022-09-02T07:02:55.496680174Z","tags":null},"/posts/fixed-rate-protocols/fixed-rate-protocols":{"title":"","content":"# Fixed Income Protocols\n\nDeFi's next wave of protocols has come through fixed income protocols. I will go deep into yield curves based protocols i.e. [Yield](https://yield.is), [Notional](https://notional.finance), [Uma]().\n\n## Yield Protocol\n\nYield introduced *yTokens* i.e. `Yield Tokens` similar to compound's *cTokens* which essentially behaves as zero-coupon bonds expiring at a future date and can be redeemed 1-on-1 for the underlying asset.\n\n*yTokens* can be building blocks that can be used to make many other interesting products. Market price of *yTokens* can be used as interest rate oracle. Each yToken has its own interest rate over the period to expiration date which can be used by many other protocols to settle on-chain interest rate derivatives.\n\n*yTokens* differ from each other in four aspects:\n\n1. Underlying Asset\n2. Collateral Asset\n3. Collateralization requirement\n4. Expiration Time\n\n## Actors\n\n### Borrowers\n\nBorrowers is when actor opens a vault, takes out *yToken* and sells it. It is essentially shorting the underlying asset or longing the collateral asset.\n\n### Lenders\n\nBuying yTokens are similar to lending the underlying asset in which the holder of yToken is earning an interest on the underlying asset in the form of the discount which it gets when buying the yTokens.\n\n## Settlement\n\nyTokens can be construcuted using 3 main principals.\n\n### Cash settlement\n\nCash Settlement is paid in the collateral asset, which implies that it depends on a dependent price oracle that determines the price of underlying asset in terms of collateral asset.\n\nAt the moment of maturity, anyone can call the contract to trigger *settlement*, that redeems the *yTokens* for its equivalent value in collateral asset. After the moment of settlement, *yTokens* begin to track the price of collateral asset rather than the price of underlying asset but can only be redeemed at the price of settlement.\n\nThis mechanism has an advantage that it can support any asset and not just ERC20 assets as it just needs a price oracle to compare the price of yTokens with the collateral asset.\n\n### Physical settlement through auctions\n\nAt the time of minting a yToken, it is backed using the collateral asset. Minting the tokens adds to the vault's owner debt which shouldn't be less than the value of the collateral asset plus some required margin.\n\nWhen a target asset is also an ERC20 token, its settlement can be triggered physically i.e. holders get paid in underlying asset rather than collateral assets through auctions.\n\nGradual dutch auctions are held to sell the collateral for the underlying asset. Remaining collateral is returned back to the vault owner and underlying tokens earned during the auction is ditributed among *yToken* holders.\nIf auction is not completed successfully, collateral asset is distributed amont the holders along with physical assets.\n\nAdvantage over cash settlement is that after the auction is successfully done, each *yToken* is backed equally with the underlying asset rather than some collateral asset. Holders can redeem the underlying asset (but doesn't earn yield on it).\n\n### Synthetics Settlement\n\nWhen the target asset itself is a collateralized synthetic asset like DAI, *yToken* uses token's own issuance mechanism as settlement.\n\nIn case of DAI, if yDAI backed with ETH as collateral matures, the protocol creates a vault in MakerDAO with ETH as collateral. When yDAI holders come to redeem, it borrows DAI from Maker and pay to the yDAI holders. Essentialy fixed rate position in yTokens turns into variable rate debt position at the time of maturity for these synthetic assets. yDAI holders need to pay the interest for their debt position and can earn DAI savings rate as well.\n\nAdvantage is that borrowers' and lenders' position is not settled and have the option to keep it open with the synthetic token's own mechanisms.\n\n## Interest Rate oracle\n\n*yTokens's* price in itself throughout the period until maturity can be treated as an interest rate oracle as the *yTokens* price floats freely depending on the supply and demand.\n\n$$Y = (\\frac{F}{P})^{\\frac{1}{T}} - 1$$\n\n---\n\n## YieldSpace AMM\n\nA new invariant based AMM introduced to trade *fyTokens* introduced in yield paper which incorporates time into the AMM equation.\n\n$$x^{1-t}+y^{1-t} = k$$\n\n$y$ = reserves of *fyToken*,\n\n$x$ = reserves of underlying token.\n\n$t$ = time to maturity\n\n---\n\n![yieldspace curve](../assets/yieldspace_curve.png)\n\nThis formula works as constant sum protocol when $t-\u003e0$, and constant product formula when $t-\u003e1$.\n\nThis formula is defined in the yield space rather than the price space as designed in previous AMM formulas such that marginal interest rate of fyTokens at any time is equal to ratio of fyToken reserve to underlying token reserve minus 1.\n\n$$r = \\frac{y}{x} - 1$$\n\nThis formula does not have any time component, thus ensures that marginal interest rate remains proportional to fyToken and underlying token reserves at any point in time. This implies that as the allocation of fyToken in the pool increases or underlying token decreases so does the interest rate and buying pressure arises, and vice versa.\n\n## Why not other invariants\n\n1. Constant sum invariant only works for assets of similar value, and fyToken generally is priced at a discount until maturity date.\n2. Constant product formula includes liquidity at whole price spectrum but when the fyToken approaches maturity, its price tend to be similar to underlying token and thus the liquidity at other price points are wasted and larger trades have significant impact on interest rates.\n3. Curve's stableswap equation doesn't let it modify $\\chi$ to account for variation in interest rates due to time to maturity.\n\n## Properties\n\n$$x^{1-t}+y^{1-t} = x_{start}^{1-t} + y_{start}^{1-t}$$\n\nMarginal price for a given $x_{start}$, $y_{start}$, and $t$ is given by the formula:\n\n$$(\\frac{y}{x})^t = (\\frac{(x_{start}^{1-t} + y_{start}^{1-t} - x^{1-t})^\\frac{1}{1-t}}{x})^t$$\n\n![token price vs reserves](../assets/dai_price_vs_dai_reserves.png)\n\nLooking at interest rates,\n\n![interest rate vs dai reserves](../assets/interest_rate_vs_dai_reserves.png)\n$$\\frac{y}{x} - 1 = \\frac{(x_{start}^{1-t} + y_{start}^{1-t} - x^{1-t})^\\frac{1}{1-t}}{x} - 1$$\n\n## Fees\n\nLP are incentivised to provide liquidity using the fees that they earn. Since, constant sum power formula is defined in yield space and not price space, it's not meaningful to impose fees on price and rather on interest rates i.e. any buyer of fyToken should get lesser interest rates or higher buy price.\n\nThus, the fee formula modifies the interest rate by adding a variable $g \u003c 1$ to change interest rates.\n\n$$r = (\\frac{y}{x})^g - 1$$\n\n\u003e Note that this formula is used for buying fyTokens, $\\frac{1}{g}$ is used when selling fyTokens.\n\nThus, the new AMM formula becomes\n\n$$x^{1-gt}+y^{1-gt} = k$$\n\n## Capital Efficiency\n\nOriginal protocol allows user to mint 1 fyToken in exchange of 1 underlying token and there is no real incentive to buy a fyToken above the underlying token price. Thus, the pool always checks at the end of every trade that price of 1 fyToken is not greater than 1 underlying token or reserves of fyToken is greater underlying. Thus, Some portion of fyToken reserves in the pool is always inaccessible. Example can be when pool is first initialized, the equal fyToken in the pool is never utilised as the remaining fyToken can't be sold.\n\nSo, the capital efficieny of the pool is improved by making the excess fyToken's reserves `virtual`. LPs don't need to contribute these access reserves. Pool uses liquidity tokens `s` as the virtual fyTokens reserves. Whenever a trade occurs, `virtual` tokens are added to actual reserves to calculate the appropriate amount but whenver liquidity is added, only the real reserves are used to calculate fyTokens in proportion to the actual fyToken in pool.\n\n## Resources\n\n- [Yield Paper](https://research.paradigm.xyz/Yield.pdf)\n- [Yieldspace paper](https://yield.is/YieldSpace.pdf)\n- [Element finance paper](https://paper.element.fi//)\n- [Sense](sense-finance.md)\n- [Messari's Fixed Income Protocol](https://messari.io/article/fixed-income-protocols-the-next-wave-of-defi-innovation)\n- [Designing Yield Tokens](https://medium.com/sensefinance/designing-yield-tokens-d20c34d96f56)\n- [Swivel's cash flow instruments Pt.1](https://swivel.substack.com/p/cash-flow-instruments-pt-1-history?s=r)\n- [Defization of fixed income products](https://medium.com/coinmonks/the-defization-of-fixed-income-products-7e72ed4f57b1)\n- [Defixed income](https://medium.com/@exactly_finance/defixed-income-101-948976c0e2c6)\n- [Notional](https://medium.com/coinmonks/notional-the-alpha-of-fixed-income-defi-products-a5637d2092b5)\n- [](https://medium.com/finoa-banking/turning-proof-of-stake-yield-into-fixed-income-products-7de8a73097ac)\n- [Fixed Income Protocols](https://medium.com/gamma-point-capital/fixed-income-protocols-the-next-wave-of-defi-innovation-69215be82b4e)\n\n\n## Questions\n\n- What are fixed yield rate protocols?\n- different types of protocols currently\n\nmainly three types: tranches, zero-coupon and stripping. Sense follows stripping architecture\n\n- what are tranches based and zero-coupon based?\n\ntranches are where users provide their assets and protocols invests in different strategies on the basis of risks of the tranche. More risk assosciated. Each protocol has their own set of safety backstops to stop protocol from being insolvent.\n\nZero coupon based protocols essentialy turn the asset into a bond which is traded at a discount and is exchangeable 1-1 at maturity.\n\nSense follows stripping architecture that allows it to strip target into PT and YT. Note that target in Sense can be yield bearing assets. This yield is given then to YTs.\n\n- What are yield or notional doing?\n\nyield issues zero-coupon bonds taking collateral and giving fyTokens. susceptible to liquidations in volatile markets.\n\n- what is 88mph or barnbridge doing?\n\n88mph/barnbridge uses lending market protocols like compound, aave to provide fixed yields to deposited assets. These fixed interest rate models are determined by governance. These protocols are prone to drop in interest rate offered by the variable markets after the deposit. They offset this by issuing Floating rate bonds to users for the extra yield. This model is hard to scale, requires governance at every step, not risk-free for users as they can't exit at will because the firb are issued at fixed terms.\n\n- Why yield stripping and not others?\n\ntranches not safe, and zero-coupon bonds mainly use underlying assets which does not take into account the yield. Stripping applications takes a yield bearing assets and gives the user security against their principal in PTs and yields in YTs. So, its just more safer and transparent for users, better abstractability and flexibilty for devs and users as they can plug these PT or YT further.\n\n- Sense space?\n- yieldspace pools\n\nmakes sense to account for implied rate and liquidity to be spread around interest rate rather than the price as price there is function of rate itself. space better as target is deposited, no IL, yield goes to LPs.\n\n- How are PTs and YTs priced?\n\nStripping protocols follows the invariant that PTs + YTs at any point = Target. At the time of series creation, YTs are the claim to the yield and PTs trade at discount which is Target - YTs. As maturity approaches, PTs tend towards the price of target 1 on 1.\n\nPTs are priced according to formula $(\\frac{y}{x})^{\\frac{1}{t}}$, where x and y are reserves in pool.\n\nYTs are priced according to the yield payments that they're going to receive till maturity. So, if 4 yield payments of $0.1, then $0.4 is their price.\n\n- What is a series?\n\nseries is a specific set of PTs and YTs of a target with specific maturity and specific adapter.\n\n- list all common sc attack patterns?\n\nunverified calls, dos, delegatecalls, signature malleability, re-entrancy, arithmetic over/underflows, randomisation in evm, tx.origin, selfdestruct\n\n- compound, aave, fuse?\n\n- what is your thinking when designing some project?\n\ndepends on the project,\n\n1. swap\n2. lend\n\nthen thinking about actors and their actions, then modules, external interactions\n\nuniswap like structure i.e. core and periphery. Anybody can directly build on core and periphery is used for normal user interaction with the protocol.\n\n- How do you guys take an idea from different phases to mainnet?\n- do you use other tools to test your smart contracts like slither, echidna ?\n-","lastmodified":"2022-09-02T07:02:55.496680174Z","tags":null},"/posts/fixed-rate-protocols/sense-finance":{"title":"","content":"# Sense Finance\n\n## Sense space\n\nSense uses yieldspace invariant to create PT/target AMM pools built on balancer. YT can also be traded in the pool using *zap* transactions.\n\n### Zap transactions\n\nYield token trading can occur using sense space.\n\n![trade_yts](../assets/target_trading.png)\n\nTo trade target for YTs,\n\n1. flash loan target from sense at 0% fees\n2. Put target into sense and take PTs and YTs\n3. swap PTs -\u003e target\n4. pay back flash loan\n5. return YTs and extra target\n\nTrade YTs for target\n\n1. flash loan target from sense\n2. swap target -\u003e PTs\n3. Put PTs and YTs in sense for target\n4. pay back flash loan\n5. return extra target\n\n### LPs\n\nEach series has its own space pool built, for which LPs can provide liquidity.\n\n![LPs](../assets/space_lps.png)\n\nTo deposit into pools,\n\n1. deposit target into sense for PTs and YTs\n2. deposit target and PTs into space\n3. LPs can choose to immediately sell YTs or keep it and trade it later\n4. Return extra target, LP shares, and YTs\n\nRemoving the liquidity,\n\n1. Get target and PTs back from space using LP shares\n2. Either, swap PTs for target in sense after maturity or swap in space.\n\n### LP Returns\n\nDepends on three main criteria,\n\n1. Fixed yield on PTs\n2. yield on target i.e. yield bearing assets\n3. space trading fees\n\n## Use cases\n\n- Fixed rate earners\n- trading on future yield\n- longing future yield\n- lp returns\n- series actors/managers\n- fuse lenders/borrowers\n- arbitrageurs\n\n### Space pool LP returns\n\n\n## Sense Implementation\n\nCheck out [Sense implementation file](./sense-finance-impl.md) and [Sense Math](sense-math.md).\n\n## Resources\n\n- [Medium](https://medium.com/sensefinance)\n- [Github](https://github.com/sense-finance)\n- [Website](https://sense.finance)\n- [Sense interactions](https://docs.google.com/spreadsheets/d/1u--kIr18av6RPTyTZbs_ryMVv2maSsd-NxDFpUkF-Uo/edit#gid=0)","lastmodified":"2022-09-02T07:02:55.496680174Z","tags":null},"/posts/fixed-rate-protocols/sense-finance-impl":{"title":"","content":"# Sense Implementation\n\n![contracts](../assets/22.03.16-v1-contract-diagrams.966aeccc.png)\n\n## Space pool implementation\n\n### SpaceFactory\n\nstorage:\n\n```solidity\nvault\ndivider\nts\ng1\ng2\nmapping(adapter -\u003e maturity -\u003e poolAddress)\n```\n\nFunctions:\n\n```solidity\ncreatePool\nsetPool\nsetParams\n```\n\n### Space\n\nstorage:\n\n```solidity\nadapter\nmaturity\npti     // Principal token index (basically token0 or token1)\nts      // timestamp used in invariant\ng1      // fees based g, which is used in the invariant\ng2\n\npoolId\ntoken0\ntoken1\nscalingFactorPT             // expressed as 10**18 - decimals(ptToken)\nscalingFactorTarget         // 10**18 - decimals(targetToken)\nvault                       // vault interface\nprotocolFeesCollector       // vault fees collector\n\ninitScale                   // adapter init scale ?\ntoken{0,1}Reserves\n\noracleData\n```\n\n**Public Functions**:\n\n`onJoinPool(bytes32 poolId, address sender, address recipient, uint256[] memory reserves, uint256 lastChangeBlock, uint256 protocolSwapFeePercentage, bytes memory userData)`\n\n1. check `maturity`\n2. get `reqAmountsIn` and `minBptOut` from `userData`\n3. upscale `reserves` and `reqAmountsIn` to `18` decimals\n4. check if `totalSupply == 0`\n5. If true, then liq. getting added first time\n   1. send minBpt to address(0)\n   2. mint bptToken - minBpt to recipient\n   3. downscale reqAmount\n   4. cache reserves\n6. If false,\n    1. update oracle with upscaled reserves\n    2. give fees to `protocolFeesCollector` by minting BPT tokens\n    3. mint BPT tokens to recipient\n    4. calculate `tokensInForBptOut`\n    5. cacheReserves\n    6. downscale reserves\n\n`onExitPool(uint256 poolId, address sender, address recipient, uint256[] memory reserves, uint256 lastBlockChange, uint256 protocolSwapFeePercentage, bytes memory userData)`\n\n1. upscale array `reserves`\n2. update oracle\n3. give fees to `protocolFeesCollector`\n4. get bpt amount from user data\n5. calculate token amounts out by rounding up\n6. burn bpt\n7. change reserves\n8. cache reserves\n9. downscale array amountsOut\n10. return\n\n`onSwap(SwapRequest request, uint256 reserveTokenIn, uint256 reserveTokenOut)`\n\n1. check swap direction with variable `ptIn`\n2. upscale `reservesToken{In,Out}`\n3. update oracle if `msg.sender == vault`\n4. calculate reserves as per the direction\n   1. if ptIn, add virtual reserves as per yieldspace paper to *PT* and scale target according to adapter\n   2. if targetIn, scale target and add virtual reserves to PT\n5. check swap kind,\n6. if `swapKind.GIVEN_IN`,\n   1. upscale `request.amount` with `scalingFactorTokenIn`\n   2. if in token not PT, mul `request.amount` with adapter\n   3. get amountOut from `_onSwap`\n   4. if outToken target, scale `amountOut` with adapter\n   5. return amountOut\n7. if `swapKind.GIVEN_OUT`,\n   1. upscale request.amount with scalingFactorTokenOut\n   2. if ptIn, scale `request.amount` with adapter\n   3. calculate amountIn with _onSwap\n   4. if not ptIn, scale `amountIn` with adapter\n   5. return amountIn\n\n#### **Internal Functions**\n\n`_onSwap`: calculates amountIn or amountOut based on the direction using invariant calculation\n\n`_tokensInForBptOut`: two cases, when no PTReserves and when reserves is present. No liq is possible when new pool or when PT is swapped out\n\n1. when pt reserves 0, bptToMint = amountTargetIn scaled with adapter\n2. else calculate bptToMint using both target and PT and use whichever's lesser\n\n`_cacheReserves`: caches the reserve, if oracle enabled caches invariant as well\n\n`_updateOracle`: updates oracle indexes on current timestamp\n\n#### **Mocks/Test Utils**\n\n**User** submits his liquidity to space using `join`, exits using `exit` and `swapIn`, `swapOut` for swapping PT/target tokens in the pool.\n\n```solidity\njoin(reqPrincipalIn, reqTargetIn)\nexit(bptAmountIn)\nswapIn(principalIn, amountIn)\nswapOut(principalIn, amountOut)\n```\n\n#### **Tests**\n\n`testSimpleSwapIn`:\n\n- join\n- swap in with target to get PT out, but fails bc no PT in pool\n- swap in with PT and get some target out\n- assert PT and target balances in pool\n- test swap full target\n- now, swap in with target and get PT out\n\n**Notes**:\n\n- First join is always target-only, you can't `swapIn` using PT. So, `swapIn(false, amount)` doesn't work after first join.\n\n---\n\n## Sense\n\n### Series\n\nA series is a particular set of PTs and YTs with a specific target, adapter, and maturity.\n\nSense core contracts is based on hub and spoke model, where hub is the *Divider* contract and *spokes* are contracts that surround Divider like Adapters.\n\n---\n\n### AdapterFactory\n\nBaseFactory -\u003e CropFactory/CropsFactory\n\n`BaseFactory`: `CropFactory` and `CropsFactory` are extensions used to deploy crop and crops respectively.\n\n```solidity\naddress divider;                            // divider address\nmapping(address =\u003e address) adapters;       // target -\u003e adapter\nstruct FactoryParams {\n  address oracle; // oracle address\n  address stake; // token to stake at issuance\n  uint256 stakeSize; // amount to stake at issuance\n  uint256 minm; // min maturity (seconds after block.timstamp)\n  uint256 maxm; // max maturity (seconds after block.timstamp)\n  uint128 ifee; // issuance fee\n  uint16 mode; // 0 for monthly, 1 for weekly\n  uint64 tilt; // tilt\n}\n```\n\n---\n\n### Adapters\n\nBaseAdapter -\u003e Implementation (Compound, Fuse, Lido)\n\nsurround divider and holds logic for a particular application. For example, compound, fuse adapters are built and then different series can be created using these adapters.\n\n`BaseAdapter` Parameters:\n\n1. `target`\n2. `underlying`\n3. `oracle`\n4. `stake`: token to stake at issuance\n5. `stakeSize`: amount to stake at issuance\n6. `minm`: minimum maturity\n7. `maxm`\n8. `mode`: maturity date type, 0 for monthly, 1 for weekly\n9. `ifee`: issuance fee\n10. `tilt`: principal set aside for YTs at maturity\n11. `level`: feature access codes. \u003conRedeem(y/n)\u003e\u003ccollect(y/n)\u003e\u003ccombine(y/n)\u003e\u003cissue(y/n)\u003e. example: 0101\n\nEvery implementation has to inherit BaseAdapter and override these following functions:\n\n1. `scale`: represents exchange price b/w target and underlying, is assosciated with each adapter and vary wrt to each adapter.\n2. `getUnderlyingPrice`\n3. `wrapUnderlying`\n4. `unwrapTarget`\n\nOther functions include:\n\n1. `flashLoan`\n2. `maxFlashLoan`\n3. `onRedeem`: hook function when user redeems PT\n4. `notify`: fn for airdrop tokens to distribute to user.\n\n`Extensions`: Crop/Crops\n\n1. `Crop` is utility for single airdrop token. to call notify and distribute. Similarily, `CropFactory` extends BaseFactory for airdrop tokens and set the airdrop token address.\n\n2. `Crops`: is utility for multiple airdrop tokens. `CropsFactory` Sets multiple airdrop tokens addresses.\n\n```solidity\naddress reward;       // rewarded token address\nuint256 rewardBal;    // rewarded token amount distributed till now\nuint256 share;        // ?\nuint256 totalTarget;  // ? total target accumulated by all users\nmapping(address =\u003e uint256) public tBalance;      // target balance per user\nmapping(address =\u003e uint256) public rewardBalance;   // reward balance per user\n```\n\nFunctions:\n\n`notify(address usr, uint256 amt, bool join)`: update adapter values for rewarded tokens and distribute rewards to user.\n\n---\n\n### CAdapter: `crop`\n\n`wrapUnderlying(uint256 uBal)`\n\n### WstETHAdapter: `crop`\n\nTarget/Underlying: WstETH/WETH\n\n`wrapUnderlying`: weth -\u003e eth -\u003e steth -\u003e wsteth\n\n- transfer weth from user\n- convert to eth\n- stake eth for steth\n- convert steth to wsteth\n- transfer back to user\n\n`unwrapTarget`: wsteth -\u003e steth -\u003e eth -\u003e weth\n\n- transfer wsteth from user\n- unstake to steth\n- swap for eth on curve\n- wrap to weth and transfer to user\n\n### FAdapter: `crops`\n\n`wrapUnderlying`\n\n- get underlying from user\n- if FETH, deposit weth to get ETH\n- mint target accordingly, i.e ftoken or feth\n- send to user\n\n`unwrapTarget`\n\n- get target from user\n- redeem target for underlying\n- if FETH, deposit feth underlying to WETH contract\n- send underlying back to user by uBalAfter - uBalBefore\n\n---\n\n### Divider\n\n*issue*/*combine* PTs and YTs, *redeem* and *collect* target.\n\n```solidity\nstruct Series {\n  address yt;\n  uint48 issuance;\n  address pt;\n  uint96 tilt;        //  % of underlying principal initially reserved for Yield\n  address sponsor;\n  uint256 reward;\n  uint256 iscale;\n  uint256 mscale;\n  uint256 maxscale;\n}\n\nstruct AdapterMeta {\n  uint256 id;\n  bool enabled;\n  uint256 guard;      // Max amount of target allowed to be issued\n  uint256 level;      // adapter level (mentioned above)\n}\n\n// adapter -\u003e maturity -\u003e series;\nmapping(address =\u003e mapping(uint256 =\u003e Series)) series;\n// Adapter info\nmapping(address =\u003e AdapterMeta) adapters;\n// adapter -\u003e maturity -\u003e user -\u003e lscale (last scales) ?\nmapping(address =\u003e mapping(uint256 =\u003e mapping(address =\u003e uint256))) lscales;\n```\n\n#### Functions\n\n`function issue(address adapter, uint256 maturity, uint256 tBal) returns (uint256 uBal)`\n\nissuance scale is used\n\n- basic checks: adapter valid, series exists, series not already settled\n- check if adapter level authorises issuance\n- get adapter ifee, target\n- find $fee = tBal*ifee$ and get `tBalSubFee`\n- add fee to series reward\n- check adapter `guard` cap\n- notify adapter and update values\n- scale = series.iscale or adapter scale\n- find $uBal = tBalSubFee * scale$\n- update user lscale value, if first init then scale else harmonic mean\n- mint PT and YT\n- transfer target to divider\n\n`function redeem(address adapter, uint256 maturity, uint256 uBal)`\n\nscale is either mscale or maxscale depending on zshare\n\n- mandatory checks: adapter valid, series settled\n- check if redeem enabled\n- burn PT\n- convert uBal to tBal after checking `zShare = 1 - tilt`\n- transfer target\n\n`function combine(address adapter, uint256 maturity, uint256 uBal) returns (uint256 tBal)`\n\nsince this is before maturity, scale is either current scale or last scale\n\n- check adapter, series\n- burn pt\n- get cscale as mscale\n- collect extra YT\n- if series not settled, burn YT as it won't burn in collect and change cscale to current\n- get $tBal = uBal / cscale$\n- transfer tBal target to msg.sender\n- notify adapter\n- update `tBal += collected` from YT _collect\n\n`function collect(address adapter, uint256 maturity, uint256 uBal)`\n\n-\n\n---\n\n### Periphery\n\n```solidity\ndivider\nBalanceVault balancerVault\nPoolManager poolManager\nSpaceFactoryLike spaceFactory\nmapping(address =\u003e bool) factories\nmapping(address =\u003e bool) verified;\n```\n\n`function swapTargetForPTs`\n`function swapTargetForYTs`\n`function swapUnderlyingForPTs`\n`function swapUnderlyingForYTs`\n`function swap`","lastmodified":"2022-09-02T07:02:55.496680174Z","tags":null},"/posts/fixed-rate-protocols/sense-math":{"title":"","content":"# Sense Math\n\n## Notation\n\n$s(t)$\n: the scale at the time $t$, i.e. the price of the Target token in the underlying token terms at the time moment $t$\n\n$\\theta$\n: The tilt value, i.e. the part of the principal that belong to Claims\n\n$t_0$\n: The issue time\n\n$t_m$\n: The maturity time\n\n$S(t)$\n: The maximum scale value earnings were collected at up until the time moment $t$\n\n$x$\n: The amount of the Target token being deposited by a user\n\n$X$\n: The effective amount of the Target token being deposited\n\n$\\Delta x$\n: The addition amount of the Target token, collected during issuance and added to the amount deposited by the user\n\n$y$\n: An amount of Zero or Claim token\n\n$x_z$\n: The ideal amount of the Target token redeemed by a Zero holder\n\n$X_z$\n: The actual amount of the Target token redeemed by a Zero holder\n\n$x_c$\n: The ideal total amount of the Target token redeemed by a Claim holder\n\n$x'_c$\n: The ideal amount of the Target token redeemable by a Claim holder before maturity\n\n$x''_c$\n: The ideal amount of the Target token redeemable by a Claim holder after maturity\n\n$X_c$\n: The actual total amount of the Target token redeemed by a Claim holder\n\n$X''_c$\n: The actual amount of the Target token redeemable by a Claim holder after maturity\n\n## Issue\n\nAt the time moment $t_0$, a user deposits $x$ amount of the Target token.  He gets: $y = x \\cdot s(t_0)$ units of Zero token, and the same amount of Claim token.\n\nIn case $s(t_0) \u003c S(t_0)$ the user may immediately collect a certain amount of the Target tokens from just issued Claim token.  It would be reasonable to consider this addition amount of the Target token to be added to the original deposited amount.  The exact additional amount could be found from the following equation:\n\n$$\n\\Delta x = (x + \\Delta x) \\cdot s(t_0) \\cdot \\left( \\frac{1}{s(t_0)} - \\frac{1}{S(t_0)} \\right) = (x + \\Delta x) \\cdot \\left( 1 - \\frac{s(t_0)}{S(t_0)} \\right) \\\\\n\\Delta x \\left( 1 - \\left( 1 - \\frac{s(t_0)}{S(t_0)} \\right) \\right) = x \\cdot \\left( 1 - \\frac{s(t_0)}{S(t_0)} \\right) \\\\\n\\Delta x \\cdot \\frac{s(t_0)}{S(t_0)} = x \\cdot \\left( 1 - \\frac{s(t_0)}{S(t_0)} \\right) \\\\\n\\Delta x = \\frac{x \\cdot \\left( 1 - \\frac{s(t_0)}{S(t_0)} \\right)}{\\frac{s(t_0)}{S(t_0)}} = x \\cdot \\left( \\frac{S(t_0)}{s(t_0)} - 1 \\right)\n$$\n\nSo the full deposited amount is:\n\n$$\nX = x + \\Delta x = x + x \\cdot \\left( \\frac{S(t_0)}{s(t_0)} - 1 \\right) = x \\cdot \\frac{S(t_0)}{s(t_0)}\n$$\n\nand the full amount of issued tokens (the same for Zero and Claim tokens) is:\n\n$$\nY = X \\cdot s(t_0) = x \\cdot \\frac{S(t_0)}{s(t_0)} \\cdot s(t_0) = x \\cdot S(t_0)\n$$\n\nNote, that the outcome for the user is as if the current scale was $S(t_0)$ rather than $s(t_0)$. Thus is would be reasonable for the protocol to use the current max scale instead of the current scale when calculating the number of Zeros and Claim to be issued.\n\nIn case the user already have some amount of Claim token when issuing more tokens, earnings should be collected from these Claim token amount before issuing more Claim token.  Let's assume that the user already has the amount $Y_l$ of Claim token and earnings were last colected at the time $t_l$. Then the user may collect the following amount $x_l$ of Target token from his existing Claim holdings:\n\n$$\nx_l = Y_l \\cdot \\left( \\frac{1}{s(t_l)} - \\frac{1}{S(t_0)} \\right)\n$$\n\nThus the full amount of issued tokens, that takes into account the collected earnings from existing Claim holdings, is:\n\n$$\nY = \\left( x + Y_l \\cdot \\left( \\frac{1}{s(t_l)} - \\frac{1}{S(t_0)} \\right) \\right) \\cdot S(t_0)\n$$\n\n## Redeem\n\n### Ideal Case\n\nIn the ideal case, when a user redeems $y$ amount of Zero token, he gets the following amount of the Target token:\n\n$$\nx_z =\ny\\frac{(1 - \\theta)}{s(t_m)}\n$$\n\nIn the ideal case, when a user redeems $y$ amount of Claim token, he gets the following total amount of the Target token:\n\n$$\nx_c =\ny\\left( \\frac{\\theta}{s(t_m)} + \\frac{1}{s(t_0)} - \\frac{1}{s(t_m)} \\right) =\ny \\left( \\frac{1}{s(t_0)} - \\frac{(1 - \\theta)}{s(t_m)} \\right)\n$$\n\nNote that:\n\n$$\nx_z + x_c =\n\\frac{y}{s(t_0)} =\n\\frac{x \\cdot s(t_0)}{s(t_0)} =\nx\n$$\n\ni.e. the whole deposited amount is redeemed.\n\n### Real Case\n\nThe following amount could be collected by Claim token holders before maturity:\n\n$$\nx'_c =\ny\\left( \\frac{1}{s(t_0)} - \\frac{1}{S(t_m)} \\right)\n$$\n\nSo the following amount is to be collected after maturity:\n\n$$\nx''_c =\nx_c - x'_c =\ny\\left( \\frac{1}{s(t_0)} - \\frac{(1 - \\theta)}{s(t_m)} \\right) - y\\left( \\frac{1}{s(t_0)} - \\frac{y}{(t_m)} \\right) = y\\left( \\frac{1}{S(t_m)} - \\frac{(1 - \\theta)}{s(t_m)} \\right)\n$$\n\nAs it is impossible to collect a negative amount, the actual amount collected after maturity is:\n\n$$\nX''_c =\n\\max (0, x''_c) =\n\\max \\left( 0, y\\left( \\frac{1}{S(t_m)} - \\frac{(1 - \\theta)}{s(t_m)} \\right) \\right)\n$$\n\nThus the actual total amount of the Target tokens got by the Claim token hoder is:\n\n$$\nX_c =\nx'_c + X''_c =\ny\\left( \\frac{1}{s(t_0)} - \\frac{1}{S(t_m)} \\right) + \\max \\left( 0, y\\left( \\frac{1}{S(t_m)} - \\frac{(1 - \\theta)}{s(t_m)} \\right) \\right)\n$$\n\nand the actual amount of the Target tokens got by the Zero token holder is:\n\n$$\nX_z =\nx - X_c =\n\\frac{y}{s(t_0)} - y\\left( \\frac{1}{s(t_0)} - \\frac{1}{S(t_m)} \\right) - \\max \\left( 0, y\\left( \\frac{1}{S(t_m)} - \\frac{(1 - \\theta)}{s(t_m)} \\right) \\right) =\\\\=\ny\\left( \\frac{1}{S(t_m)} - \\max \\left( 0, \\left( \\frac{1}{S(t_m)} - \\frac{(1 - \\theta)}{s(t_m)} \\right) \\right) \\right)\n$$\n\n### Sunny Day\n\nWhen\n\n$$\ny\\left( \\frac{1}{S(t_m)} - \\frac{(1 - \\theta)}{s(t_m)} \\right) \\geqslant 0\n$$\n\nwe have:\n\n$$\nX_c =\ny\\left( \\frac{1}{s(t_0)} - \\frac{1}{S(t_m)} \\right) + \\max \\left( 0, y\\left( \\frac{1}{S(t_m)} - \\frac{(1 - \\theta)}{s(t_m)} \\right) \\right) =\\\\=\ny\\left( \\frac{1}{s(t_0)} - \\frac{1}{S(t_m)} \\right) + y\\left( \\frac{1}{S(t_m)} - \\frac{(1 - \\theta)}{s(t_m)} \\right) =\\\\=\ny\\left( \\frac{1}{s(t_0)} - \\frac{(1 - \\theta)}{s(t_m)} \\right) = x_c\n$$\n\n$$\nX_z =\ny\\left( \\frac{1}{S(t_m)} - \\max \\left( 0, \\left( \\frac{1}{S(t_m)} - \\frac{(1 - \\theta)}{s(t_m)} \\right) \\right) \\right) =\\\\=\ny\\left( \\frac{1}{S(t_m)} - \\left( \\frac{1}{S(t_m)} - \\frac{(1 - \\theta)}{s(t_m)} \\right) \\right) =\\\\=\ny \\frac{(1 - \\theta)}{s(t_m)} = x_z\n$$\n\nSo, in a sunny day scenario, $X_z = x_z$ and $X_c = x_c$.\n\n### Not So Sunny Day\n\nWhen the day is not so sunny, i.e.\n\n$$\ny\\left( \\frac{1}{S(t_m)} - \\frac{(1 - \\theta)}{s(t_m)} \\right) \u003c 0\n$$\n\nwe have:\n\n$$\nX_c =\ny\\left( \\frac{1}{s(t_0)} - \\frac{1}{S(t_m)} \\right) + \\max \\left( 0, y\\left( \\frac{1}{S(t_m)} - \\frac{(1 - \\theta)}{s(t_m)} \\right) \\right) =\\\\=\ny\\left( \\frac{1}{s(t_0)} - \\frac{1}{S(t_m)} \\right) + 0 =\\\\=\ny\\left( \\frac{1}{s(t_0)} - \\frac{1}{S(t_m)} \\right)\n$$\n\n$$\nX_z =\ny\\left( \\frac{1}{S(t_m)} - \\max \\left( 0, \\left( \\frac{1}{S(t_m)} - \\frac{(1 - \\theta)}{s(t_m)} \\right) \\right) \\right) =\\\\=\ny\\left( \\frac{1}{S(t_m)} - 0 \\right) =\\\\=\n\\frac{y}{S(t_m)}\n$$\n\n### Sunny Day Condition\n\nLets transform the sunny day condition a bit:\n\n$$\ny\\left( \\frac{1}{S(t_m)} - \\frac{(1 - \\theta)}{s(t_m)} \\right) \\geqslant 0 \\\\\n\\frac{1}{S(t_m)} - \\frac{(1 - \\theta)}{s(t_m)} \\geqslant 0 \\\\\ns(t_m) - S(t_m) \\cdot (1 - \\theta) \\geqslant 0 \\\\\ns(t_m) \\geqslant S(t_m) \\cdot (1 - \\theta) \\\\\n\\frac{s(t_m)}{S(t_m)} \\geqslant 1 - \\theta\n$$\n\n### The Final Formulas\n\nSo, the final formulas are:\n\nZero token holders get the following amount of the Target tokens after maturity:\n\n$$\nX_z =\n\\begin{cases}\ny \\frac{(1 - \\theta)}{s(t_m)} \u0026 \\text{if} \u0026 \\frac{s(t_m)}{S(t_m)} \\geqslant 1 - \\theta, \\\\\n\\frac{y}{S(t_m)} \u0026 \\text{if} \u0026 \\frac{s(t_m)}{S(t_m)} \u003c 1 - \\theta\n\\end{cases}\n$$\n\nClaim token holders get the following mount of the Target token after maturity:\n\n$$\nX''_c =\n\\begin{cases}\ny\\left( \\frac{1}{S(t_m)} - \\frac{(1 - \\theta)}{s(t_m)} \\right) \u0026 \\text{if} \u0026 \\frac{s(t_m)}{S(t_m)} \\geqslant 1 - \\theta, \\\\\n0 \u0026 \\text{if} \u0026 \\frac{s(t_m)}{S(t_m)} \u003c 1 - \\theta\n\\end{cases}\n$$\n\nClaim token holders get the following total amount of the Target tokens:\n\n$$\nX_c =\n\\begin{cases}\ny\\left( \\frac{1}{s(t_0)} - \\frac{(1 - \\theta)}{s(t_m)} \\right) \u0026 \\text{if} \u0026 \\frac{s(t_m)}{S(t_m)} \\geqslant 1 - \\theta, \\\\\ny\\left( \\frac{1}{s(t_0)} - \\frac{1}{S(t_m)} \\right) \u0026 \\text{if} \u0026 \\frac{s(t_m)}{S(t_m)} \u003c 1 - \\theta\n\\end{cases}\n$$\n\n---\n\n### The Current Formula\n\n$$\nX''_c = \\max \\left( 0, y \\cdot \\frac{\\theta}{S(t_m)} - \\left( y \\cdot \\frac{1 - \\theta}{s(t_m)} - y \\cdot \\frac{1 - \\theta}{S(t_m)} \\right) \\right)\n$$\n\n## Add Liquidity\n\n### Target $\\leftrightarrow$ Zero Pool\n\nA user wants to provide the amount $x$ of a Target token as liquidity to a Balancer pool that trades this Target token against a Zero token derived from this Target token.\n\nThe user splits the oritinal Target amount into two parts: $x = x' + x''$.  The first part $x'$ goes directly to the pool.  The second part $x''$ is used to issue Zero that will go to the pool.  The amount of Zero issued is:\n\n$$\ny = x'' \\cdot S(t)\n$$\n\nLet $X$ be the pool reserves of the Target token, and $Y$ be the pool reserves of Zero.  The user needs to provide the tokens at the same proportion, so:\n\n$$\n\\frac{x'}{y} = \\frac{X}{Y} \\\\\n\\frac{x'}{x'' \\cdot S(t)} = \\frac{X}{Y} \\\\\n\\frac{x - x''}{x'' \\cdot S(t)} = \\frac{X}{Y} \\\\\n(x - x'') \\cdot Y = x'' \\cdot S(t) \\cdot X \\\\\nx \\cdot Y = x'' \\cdot \\left( S(t) \\cdot X + Y \\right) \\\\\nx'' = x \\cdot \\frac{Y}{S(t) \\cdot X + Y}\n$$\n\n### Underlying $\\leftrightarrow$ Zero Pool\n\nA user wants to provide the amount $x$ of a Target token as liquidity to a Balancer pool that trades the Underlying token of this Target token to a Zero token derived from this Target token.\n\nThe user splits the oritinal amount into two parts: $x = x' + x''$.  The first part $x'$ is redeemed for the Underlying token.  The amount of obtained underlying token is:\n\n$$\nz = x' \\cdot s(t)\n$$\n\nThe second part $x''$ is used to issue Zero that will go to the pool.  The amount of Zero issued is:\n\n$$\ny = x'' \\cdot S(t)\n$$\n\nLet $Z$ be the pool reserves of the Underlying token, and $Y$ be the pool reserves of Zero.  The user needs to provide the tokens at the same proportion, so:\n\n$$\n\\frac{z}{y} = \\frac{Z}{Y} \\\\\n\\frac{x' \\cdot s(t)}{x'' \\cdot S(t)} = \\frac{Z}{Y} \\\\\n\\frac{(x - x'') \\cdot s(t)}{x'' \\cdot S(t)} = \\frac{Z}{Y} \\\\\n(x - x'') \\cdot s(t) \\cdot Y = x'' \\cdot S(t) \\cdot Z \\\\\nx \\cdot s(t) \\cdot Y = x'' \\cdot \\left( S(t) \\cdot Z + Y \\right) \\\\\nx'' = x \\cdot \\frac{s(t) \\cdot Y}{S(t) \\cdot Z + s(t) \\cdot Y}\n$$\n\n---\n\n### The Current Formula\n\n$$\nx'' = x \\cdot \\frac{Y}{X + Y}\n$$\n\n### Sell Claim Mode\n\n1. A user provides amount $x$ of the Target token\n2. The amount is split into two parts: $x'$ and $x''$: $x = x' + x''$\n3. The $x''$ amount is used to issue an amount $y$ of Zero and the same amount $y$ or Claim\n4. The $x'$ amount of Target and $y$ amount of Zero are put into the pool\n5. The pool return the amount $z$ of the LP token\n6. The returned LP token amount is sent to the user\n7. ... so far so good ...\n8. Some amount of the Target token is borrowed\n9. The borrowed Target tokens are used to buy the amount $y$ of Zero from the pool (we just put this amount of Zero into the pool and now bying it back!)\n10. The amount $y$ of Zero and the same amount $y$ of Claim are combined into the amount $x'$ of Target (we just split and now recombine!)\n11. A part of the proceeds from recombining is used to repay the debt\n12. The rest proceeds of recombining are returned to the user (the user just provided some amount of Target token, and now we return part of it!)\n\nThe whole schema is more or less equivalent to this one:\n\n1. A user provides amount $x$ of the Target token\n2. The amount is split into two parts: $x'$ and $x''$: $x = x' + x''$\n3. The $x''$ amount is used to buy an amount $y$ of Zero from the pool\n4. The $x'$ amount of Target and $y$ amount of Zero are put into the pool\n5. The pool return the amount $z$ of the LP token\n6. The returned LP token amount is sent to the user","lastmodified":"2022-09-02T07:02:55.496680174Z","tags":null},"/thoughts/Curve-wars":{"title":"","content":"# Curve\n\n## Resources\n\n- [defi 80/20](https://alexlittlewood.com/defi-8020)\n- [Back to the basics: uniswap, balancer, curve](https://medium.com/@kinaumov/back-to-the-basics-uniswap-balancer-curve-e930c3ad9046)\n- [Back to the basics: compound, aave](https://medium.com/@kinaumov/back-to-the-basics-compound-aave-436a1887ad94)\n- [Curve wars](https://every.to/almanack/curve-wars)\n- [The Curve Wars](https://kyrianalex.substack.com/p/the-curve-wars)\n- [curve v2 parameters](https://nagaking.substack.com/p/deep-dive-curve-v2-parameters)","lastmodified":"2022-09-02T07:02:55.496680174Z","tags":null},"/thoughts/UniswapV3":{"title":"","content":"# UniswapV3\n\nFeatures:\n\n- Concentrated Liquidity\n- Improved Price Oracle\n- Flexible Fees\n\n## Uniswap V2 IL\n\nMarket with Liquidity $L$ and Asset $X$ and $Y$ with amounts $x$ and $y$ respectively.\n$$x*y = L^2$$\nInitial Price $P$ of asset $X$ in terms of $Y$ = $y/x$, with price movement from $P$ to $P' = Pk$.\nThen,\n$$x = \\frac{L}{\\sqrt{P}}$$\n$$y = L\\sqrt{P}$$\n\nWe, introduce three terms\n\n- $V_0$, value of initial holdings in terms of Y\n- $V_1$, value when kept in pool\n- $V_{held}$, value when held\n\n$$V_0 = y*1 + x*P = 2L\\sqrt{P}$$\n$$V_1 = 2L\\sqrt{P'} = 2L\\sqrt{Pk}$$\n$$V_{held} = y + xP' = L\\sqrt{P}(1+k)$$\n$$IL(k) = \\frac{V_1 - V_{held}}{V_{held}} = \\frac{L\\sqrt{P}(2\\sqrt{k} - 1 - k)}{L\\sqrt{P}(1 + k)} = \\frac{2\\sqrt{k}}{1+k} - 1$$\n\n## Uniswap V3 Pool Maths\n\nUniswap V3 pools are different from V2 as the liquidity is not uniformly distributed from $0$ to $\\infty$, but each position functions as a separate CFMM curve.\n\n![Uniswap V3 Concetrated Liquidity](assets/UniswapV3Liquidty.png)\n\nFor an $xy=k$ curve, let $P_a$ and $P_b$ be the price range in which liquidity is deployed, then Real Reserves:\n\n$$(x + x_{offset})(y + y_{offset}) = L^2$$\n\nwhere, $x_{offset}$ and $y_{offset}$ is the point A and B at which lines $x=ky$ touch the liquidity curve. $P_b$ \u003e $P_a$, i.e. steeper the slope more is the price. Since, liquidity outside this position is irrelevant, the real reserves are obtained shifting the curve by the offsets.\n\n![Uniswap V3 Virtual Reserves](assets/UniswapV3Reserves.png)\n\nEquation of Real Reserves becomes:\n$$(x + x_{offset})(y + y_{offset}) = L^2$$\n$$(x + \\frac{L}{\\sqrt{P_b}})(y + L\\sqrt{P_a}) = L^2$$\n\nThis can be divided into three parts:\n\n1. Current Price, $P \u003c= P_a$\n\nWhen price \u003c $P_a$, all of the liquidity is in asset X, then\n\n$$(x + \\frac{L}{\\sqrt{P_b}})L\\sqrt{P_a} = L^2$$\n$$x = L\\frac{\\sqrt{P_b} - \\sqrt{P_a}}{\\sqrt{P_a}\\sqrt{P_b}}$$\n\n2. $P \u003e= P_b$\n\nWhen price \u003e $P_b$, all of the liquidity is in asset Y, then\n\n$$y = L(\\sqrt{P_b} - \\sqrt{P_a})$$\n\n3. $P_a \u003c P \u003c P_b$\n\nAssume that the price moves from P_a to P, then the amount of asset Y contributing to liquidity should be equal to amount of asset X contributing to liquidity when moving from P_b to P.\n\n$$L_x (P_b, P) = L_y(P, P_a)$$\n$$x\\frac{\\sqrt{P}\\sqrt{P_b}}{\\sqrt{P_b} - \\sqrt{P}} = \\frac{y}{\\sqrt{P} - \\sqrt{P_a}}$$\n$$x = L\\frac{\\sqrt{P_b} - \\sqrt{P}}{\\sqrt{P}\\sqrt{P_b}}$$\n$$y = L(\\sqrt{P} - \\sqrt{P_a})$$\n\n## Core\n\nUniswap's Core contracts functionality can be divided into three main components:\n\n1. Price and Liquidity\n2. TWAP Oracle\n3. Fees\n\nMain building blocks for these functionality is through `ticks` and `positions`.\n\n### Ticks\n\nA tick in terms of price is represented as:\n$$i_c = \\lfloor{\\log_{\\sqrt{1.001}}\\sqrt{P}}\\rfloor$$\n\nIn Uniswap V2, price space was continuous as the liquidity was divided across the whole space i.e. $[0, \\infty]$. V3 introduced the concept of concentrated liquidity in the form of ticks i.e. now, the price is divided discretely such that 1 tick represents 1 basis points (0.01% price change).\n\n```solidity\n// info stored for each initialized individual tick\nstruct Info {\n    // the total position liquidity that references this tick\n    uint128 liquidityGross;\n    // amount of net liquidity added (subtracted) when tick is crossed from left to right (right to left),\n    int128 liquidityNet;\n    // fee growth per unit of liquidity on the _other_ side of this tick (relative to the current tick)\n    // only has relative meaning, not absolute â€” the value depends on when the tick is initialized\n    uint256 feeGrowthOutside0X128;\n    uint256 feeGrowthOutside1X128;\n    // the cumulative tick value on the other side of the tick\n    int56 tickCumulativeOutside;\n    // the seconds per unit of liquidity on the _other_ side of this tick (relative to the current tick)\n    // only has relative meaning, not absolute â€” the value depends on when the tick is initialized\n    uint160 secondsPerLiquidityOutsideX128;\n    // the seconds spent on the other side of the tick (relative to the current tick)\n    // only has relative meaning, not absolute â€” the value depends on when the tick is initialized\n    uint32 secondsOutside;\n    // true iff the tick is initialized, i.e. the value is exactly equivalent to the expression liquidityGross != 0\n    // these 8 bits are set to prevent fresh sstores when crossing newly initialized ticks\n    bool initialized;\n}\n```\n\n### Position\n\nPosition refers to the liquidity earned after submiting tokens to the pool and measures fees earned over that position.\n\n```solidity\nstruct Info {\n  uint128 liquidity;\n\n  // fee growth after last update\n  uint256 feeGrowthInside0LastX128;\n  uint256 feeGrowthInside1LastX128;\n\n  // fees owed to position in tokens0/1\n  uint128 tokensOwed0;\n  uint128 tokensOwed1;\n}\n```\n\n### Fee Growth\n\nEach position update require updates in fees inside that range.\n\n$$\n\\begin{equation}\n  f_r = f_g - f_b(i_l) - f_a(i_u)\n\\end{equation}\n$$\n\n$$\n\\begin{equation}\n  f_a(i) =\n  \\begin{aligned}\n    \\begin{cases}\n      f_g - f_o(i) \u0026 {i_c \\ge i} \\\\\n      f_o(i) \u0026 i_c \u003c i\n    \\end{cases}\n  \\end{aligned}\n\\end{equation}\n$$\n\n$$\n\\begin{equation}\n  f_b(i) =\n  \\begin{aligned}\n    \\begin{cases}\n      f_o(i) \u0026 {i_c \\ge i} \\\\\n      f_g - f_o(i) \u0026 i_c \u003c i\n    \\end{cases}\n  \\end{aligned}\n\\end{equation}\n$$\n\n### Mint or Burn Flow\n\n```solidity\nmint(address recipient, int24 tickLower, int24 tickUpper, uint128 amount, bytes calldata data)\n\nburn(int24 tickLower, int24 tickUpper, uint128 amount)\n```\n\n1. Modify position\n   1. check ticks\n   2. update position\n      1. get position\n      2. if `liquidityDelta != 0`, `observeSingle`\n      3. update lower and upper tick with data\n      4. if either flipped, update ticks bitmap\n      5. get `feeGrowthInside{0,1}X128`\n      6. update position\n   3. if `liquidityDelta != 0`, calculate `amount0` and `amount1` according to tick range\n      1. `currentTick \u003c tickLower`: all liquidity in token0\n      2. `currentTick \u003e tickUpper`: all liquidity in token1\n      3. else, write oracle entry, calculate `amount0` and `amount1`\n2. call mintcallback or burn callback\n3. update balances if burn or check balances if mint\n\n## Oracles\n\nUniswap V2 `cumulativePrices` served as Oracles. Now, V3 introduces historical pricing\n\n## Resources and Acknowledgements\n\n- [Uniswap docs](https://docs.uniswap.org)\n- [Uniswap V3 LP Rekt](https://rekt.news/uniswap-v3-lp-rekt/)\n- [Uniswap v3 liquidity formula explained](https://atiselsts.medium.com/uniswap-v3-liquidity-formula-explained-de8bd42afc3c)\n- [Liquidty Maths in Uniswap V3](https://atiselsts.github.io/pdfs/uniswap-v3-liquidity-math.pdf)\n- [Uniswap V3 math Desmos](https://www.desmos.com/calculator/q2kxfue441)\n- [Technical Analysis of Uniswap V3](https://credmark.com/blog/a-technical-analysis-of-uniswap-v3)\n- [Impermanent Loss On Uniswap V3](https://medium.com/auditless/impermanent-loss-in-uniswap-v3-6c7161d3b445)\n- [Liquidity Providing in Uniswap v3](https://reuptake.medium.com/liquidity-providing-in-uniswap-v3-49bf3a0bd2ec)\n- [Uniswap V3 LP tokens as Perp](https://lambert-guillaume.medium.com/uniswap-v3-lp-tokens-as-perpetual-put-and-call-options-5b66219db827)\n\n### TWAP Oracles\n\n- [Uniswap Oracle attack simulator](https://blog.euler.finance/uniswap-oracle-attack-simulator-42d18adf65af)\n- [Uniswap V3 TWAP Oracle](https://medium.com/blockchain-development-notes/a-guide-on-uniswap-v3-twap-oracle-2aa74a4a97c5)\n\n### Academics\n\n- [Impermanent Loss In Uniswap V3](https://arxiv.org/abs/2111.09192)\n\n### Other Resources\n\n- [Awesome Uniswap V3](https://github.com/GammaStrategies/awesome-uniswap-v3)\n- [@Sabnock's Uniswap Resources](https://github.com/Sabnock01/uniswap-resources)\n","lastmodified":"2022-09-02T07:02:55.496680174Z","tags":null},"/thoughts/dmap-bytecode-disassembly":{"title":"","content":"# DMAP\n\n`dmap` is basically a simple global registry that stores `(zone, name, meta, data)`.\n\nUsage is divided into mainly two functions:\n\n1. `set(name, meta, data)`: sets `s=keccak256(msg.sender, name)` slot to `meta` and `s+1` slot to `data`.\n2. `get(name)`: returns `s=keccak256(msg.sender, name)` slot as `meta` and `s+1` as `data`.\n\nDecompiled using [ethervm's decompiler](https://ethervm.io/decompile/0x90949c9937A11BA943C7A72C3FA073a37E3FdD96).\n\n## Examples\n\nLet's manually step through `dmap` bytecode using set and get example.\n\nCreate `set` calldata using `abi.encodePacked(SEL, name, meta, data)` where SEL is a `4byte` selector and others are `bytes32`. So, for `set` calls, calldata length should be **100** bytes. And, `get` calldata should be **36** bytes. using `abi.encodePacked(SEL, s)` where `s` is the storage slot from `keccak256(msg.sender, name)`.\n\nFirst start with a `get` example.\n\n## GET\n\n1. Set up the free-memory pointer.\n\n```bash\n0000    60  PUSH1 0x80\n0002    60  PUSH1 0x40\n0004    52  MSTORE\n\nMEMORY:\n0040: 0x0000000000000000000000000000000000000000000000000000000000000080\n```\n\n2. Check `calldatasize` to be equal to _36_ as `get` calldata = _36_ bytes.\n\n```bash\n0005    36  CALLDATASIZE\nSTACK: 1\n0000: 0x0000000000000000000000000000000000000000000000000000000000000024 (calldatasize)\n\n0006    60  PUSH1 0x24\nSTACK: 2\n0000: 0x0000000000000000000000000000000000000000000000000000000000000024 (36 bytes)\n0001: 0x0000000000000000000000000000000000000000000000000000000000000024 (calldatasize)\n\n0008    03  SUB\nSTACK: 1\n0000: 0x0000000000000000000000000000000000000000000000000000000000000000 (sub)\n\n0009    60  PUSH1 0x22\nSTACK: 2\n0000: 0x0000000000000000000000000000000000000000000000000000000000000022 (jump location)\n0001: 0x0000000000000000000000000000000000000000000000000000000000000000 (jump condition)\n\n000B    57  *JUMPI\nSTACK: 0\n```\n\n3. load slot to stack\n\n```bash\n000C    60  PUSH1 0x04\nSTACK: 1\n0000: 0x0000000000000000000000000000000000000000000000000000000000000004 (calldata offset)\n\n000E    35  CALLDATALOAD\nSTACK: 1\n0000: 0x0000000000000000000000000000000000000000000000000000000000000001 (load calldata[0x04:0x24])\n```\n\n4. load storage slot to stack and store to `mem[0x00:0x20]`\n\n```bash\n000F    54  SLOAD\nSTACK: 1\n0000: 0x022ea9ba506e38ef6093b6ab53e48bbd60f86832000000000000000000000000 (slot value)\n\n0010    60  PUSH1 0x00\nSTACK: 2\n0000: 0x0000000000000000000000000000000000000000000000000000000000000000\n0001: 0x022ea9ba506e38ef6093b6ab53e48bbd60f86832000000000000000000000000\n\n0012    52  MSTORE\nSTACK: 0\nMEMORY:\n0000: 0x022ea9ba506e38ef6093b6ab53e48bbd60f86832000000000000000000000000 (slot value)\n0040: 0x0000000000000000000000000000000000000000000000000000000000000080\n```\n\n5. load s+1 slot to stack\n\n```bash\n0013    60  PUSH1 0x04\nSTACK: 1\n0000: 0x0000000000000000000000000000000000000000000000000000000000000004\nMEMORY:\n0000: 0x022ea9ba506e38ef6093b6ab53e48bbd60f86832000000000000000000000000\n0040: 0x0000000000000000000000000000000000000000000000000000000000000080\n\n0015    35  CALLDATALOAD\nSTACK: 1\n0000: 0x0000000000000000000000000000000000000000000000000000000000000001 (slot to retrieve)\nMEMORY:\n0000: 0x022ea9ba506e38ef6093b6ab53e48bbd60f86832000000000000000000000000\n\n0016    60  PUSH1 0x01\nSTACK: 2\n0000: 0x0000000000000000000000000000000000000000000000000000000000000001\n0001: 0x0000000000000000000000000000000000000000000000000000000000000001\nMEMORY:\n0000: 0x022ea9ba506e38ef6093b6ab53e48bbd60f86832000000000000000000000000\n\n0018    01  ADD\nSTACK: 1\n0000: 0x0000000000000000000000000000000000000000000000000000000000000002\nMEMORY:\n0000: 0x022ea9ba506e38ef6093b6ab53e48bbd60f86832000000000000000000000000\n\n0019    54  SLOAD\nSTACK: 1\n0000: 0x0000000000000000000000000000000000000000000000000000000000000000\nMEMORY:\n0000: 0x022ea9ba506e38ef6093b6ab53e48bbd60f86832000000000000000000000000\n```\n\n6. store loaded slot to `mem[0x20:0x40]`\n\n```bash\n001A    60  PUSH1 0x20\nSTACK: 2\n0000: 0x0000000000000000000000000000000000000000000000000000000000000020\n0001: 0x0000000000000000000000000000000000000000000000000000000000000000\nMEMORY:\n0000: 0x022ea9ba506e38ef6093b6ab53e48bbd60f86832000000000000000000000000\n\n001C    52  MSTORE\nSTACK: 0\nMEMORY:\n0000: 0x022ea9ba506e38ef6093b6ab53e48bbd60f86832000000000000000000000000\n0020: 0x0000000000000000000000000000000000000000000000000000000000000000\n```\n\n7. return `mem[0x00:0x40]`\n\n```bash\n001D    60  PUSH1 0x40\n001F    60  PUSH1 0x00\nSTACK: 2\n0000: 0x0000000000000000000000000000000000000000000000000000000000000000 (memory offset)\n0001: 0x0000000000000000000000000000000000000000000000000000000000000040 (memory length)\nMEMORY:\n0000: 0x022ea9ba506e38ef6093b6ab53e48bbd60f86832000000000000000000000000\n0020: 0x0000000000000000000000000000000000000000000000000000000000000000\n\n0021    F3  *RETURN\n```\n\n## SET\n\nNow, let's walkthrough a `set` case.\n\n```\nname: \"dmap\" = 0x6e616d6500000000000000000000000000000000000000000000000000000000\nmeta: \"meta\" = 0x6d65746100000000000000000000000000000000000000000000000000000000\ndata: \"data\" = 0x6461746100000000000000000000000000000000000000000000000000000000\n\ncalldata: `abi.encodePacked(0x00000000,name,meta,data)` = 0x000000006e616d65000000000000000000000000000000000000000000000000000000006d657461000000000000000000000000000000000000000000000000000000006461746100000000000000000000000000000000000000000000000000000000\n```\n\n1. Jump to `0x22` if `calldatasize \u003e 36`\n\n```bash\n0022    5B  JUMPDEST\n```\n\n2. push `name=calldata[0x04:0x24]`, `meta=calldata[0x24:0x44]`, `calldata[0x44:0x64]` to stack\n\n```bash\n0023    60  PUSH1 0x04\n0025    35  CALLDATALOAD\n0026    60  PUSH1 0x24\n0028    35  CALLDATALOAD\n0029    60  PUSH1 0x44\n002B    35  CALLDATALOAD\n\nSTACK: 3\n0000: 0x6461746100000000000000000000000000000000000000000000000000000000 (data)\n0001: 0x6d65746100000000000000000000000000000000000000000000000000000000 (meta)\n0002: 0x6e616d6500000000000000000000000000000000000000000000000000000000 (name)\n```\n\n3. store msg.sender at mem[0x00:0x20]\n\n```bash\n002C    33  CALLER\n002D    60  PUSH1 0x00\n002F    52  MSTORE\n\nSTACK: 3\n0000: 0x6461746100000000000000000000000000000000000000000000000000000000 (data)\n0001: 0x6d65746100000000000000000000000000000000000000000000000000000000 (meta)\n0002: 0x6e616d6500000000000000000000000000000000000000000000000000000000 (name)\nMEMORY:\n0000: 0x000000000000000000000000be862ad9abfe6f22bcb087716c7d89a26051f74c (caller)\n```\n\n\n4. store `name` at mem[0x20:0x40]\n\n```bash\n0030    82  DUP3\n0031    60  PUSH1 0x20\n0033    52  MSTORE\n\nSTACK: 3\n0000: 0x6461746100000000000000000000000000000000000000000000000000000000 (data)\n0001: 0x6d65746100000000000000000000000000000000000000000000000000000000 (meta)\n0002: 0x6e616d6500000000000000000000000000000000000000000000000000000000 (name)\nMEMORY:\n0000: 0x000000000000000000000000be862ad9abfe6f22bcb087716c7d89a26051f74c (caller)\n0020: 0x6e616d6500000000000000000000000000000000000000000000000000000000\n```\n\n5. calculate `keccak256(mem[0x00:0x40])` to find the storage slot\n\n```bash\n0034    60  PUSH1 0x40\n0036    60  PUSH1 0x00\n0038    20  SHA3\n\nSTACK: 4\n0000: 0xf7fbcbda33204447e5b6bf43e1ab2765746799462c92f997afb4e0d6a2fab922 (slot)\n0000: 0x6461746100000000000000000000000000000000000000000000000000000000 (data)\n0001: 0x6d65746100000000000000000000000000000000000000000000000000000000 (meta)\n0002: 0x6e616d6500000000000000000000000000000000000000000000000000000000 (name)\nMEMORY:\n0000: 0x000000000000000000000000be862ad9abfe6f22bcb087716c7d89a26051f74c (caller)\n0020: 0x6e616d6500000000000000000000000000000000000000000000000000000000\n```\n\n6. log the event `(0, 0, msg.sender, name, meta, data)`\n\n```bash\n0039    81  DUP2\n003A    83  DUP4\n003B    85  DUP6\n003C    33  CALLER\n003D    60  PUSH1 0x00\n003F    80  DUP1\n\nSTACK: 9\n0000: 0\n0001: 0\n0002: 0x000000000000000000000000be862ad9abfe6f22bcb087716c7d89a26051f74c (caller)\n0003: 0x6e616d6500000000000000000000000000000000000000000000000000000000 (name)\n0004: 0x6d65746100000000000000000000000000000000000000000000000000000000 (meta)\n0005: 0x6461746100000000000000000000000000000000000000000000000000000000 (data)\n0000: 0xf7fbcbda33204447e5b6bf43e1ab2765746799462c92f997afb4e0d6a2fab922 (slot)\n0000: 0x6461746100000000000000000000000000000000000000000000000000000000 (data)\n0001: 0x6d65746100000000000000000000000000000000000000000000000000000000 (meta)\n0002: 0x6e616d6500000000000000000000000000000000000000000000000000000000 (name)\nMEMORY:\n0000: 0x000000000000000000000000be862ad9abfe6f22bcb087716c7d89a26051f74c (caller)\n0020: 0x6e616d6500000000000000000000000000000000000000000000000000000000\n\n0040    A4  LOG4\nSTACK: 4\n0000: 0xf7fbcbda33204447e5b6bf43e1ab2765746799462c92f997afb4e0d6a2fab922 (slot)\n0000: 0x6461746100000000000000000000000000000000000000000000000000000000 (data)\n0001: 0x6d65746100000000000000000000000000000000000000000000000000000000 (meta)\n0002: 0x6e616d6500000000000000000000000000000000000000000000000000000000 (name)\nMEMORY:\n0000: 0x000000000000000000000000be862ad9abfe6f22bcb087716c7d89a26051f74c (caller)\n0020: 0x6e616d6500000000000000000000000000000000000000000000000000000000\n```\n\n\u003e Store `data` at `slot + 1`\n\n7. duplicate `data` to stack top and push `1`\n\n```bash\n0041    81  DUP2\nSTACK: 5\n0000: 0x6461746100000000000000000000000000000000000000000000000000000000 (data)\n0000: 0xf7fbcbda33204447e5b6bf43e1ab2765746799462c92f997afb4e0d6a2fab922 (slot)\n0000: 0x6461746100000000000000000000000000000000000000000000000000000000 (data)\n0001: 0x6d65746100000000000000000000000000000000000000000000000000000000 (meta)\n0002: 0x6e616d6500000000000000000000000000000000000000000000000000000000 (name)\n\n0042    60  PUSH1 0x01\nSTACK: 7\n0000: 01\n0000: 0x6461746100000000000000000000000000000000000000000000000000000000 (data)\n0000: 0xf7fbcbda33204447e5b6bf43e1ab2765746799462c92f997afb4e0d6a2fab922 (slot)\n0000: 0x6461746100000000000000000000000000000000000000000000000000000000 (data)\n0001: 0x6d65746100000000000000000000000000000000000000000000000000000000 (meta)\n0002: 0x6e616d6500000000000000000000000000000000000000000000000000000000 (name)\n```\n\n8. duplicate slot and add 1.\n\n```bash\n0044    82  DUP3\n0045    01  ADD\nSTACK: 6\n0000: 0xf7fbcbda33204447e5b6bf43e1ab2765746799462c92f997afb4e0d6a2fab923 (slot + 1)\n0000: 0x6461746100000000000000000000000000000000000000000000000000000000 (data)\n0000: 0xf7fbcbda33204447e5b6bf43e1ab2765746799462c92f997afb4e0d6a2fab922 (slot)\n0000: 0x6461746100000000000000000000000000000000000000000000000000000000 (data)\n0001: 0x6d65746100000000000000000000000000000000000000000000000000000000 (meta)\n0002: 0x6e616d6500000000000000000000000000000000000000000000000000000000 (name)\n```\n\n9. store at `storage[slot+1] = data`\n\n```bash\n0046    55  SSTORE\nSTACK: 4\n0000: 0xf7fbcbda33204447e5b6bf43e1ab2765746799462c92f997afb4e0d6a2fab922 (slot)\n0000: 0x6461746100000000000000000000000000000000000000000000000000000000 (data)\n0001: 0x6d65746100000000000000000000000000000000000000000000000000000000 (meta)\n0002: 0x6e616d6500000000000000000000000000000000000000000000000000000000 (name)\n```\n\n\u003e Next code block checks that `calldatasize=100` and storage slot should be empty.\n\n10. load slot and perform and with 1 to check if slot is empty or not\n\n```bash\n0047    80  DUP1\nSTACK: 5\n0000: 0xf7fbcbda33204447e5b6bf43e1ab2765746799462c92f997afb4e0d6a2fab922 (slot)\n0001: 0xf7fbcbda33204447e5b6bf43e1ab2765746799462c92f997afb4e0d6a2fab922 (slot)\n0002: 0x6461746100000000000000000000000000000000000000000000000000000000 (data)\n0003: 0x6d65746100000000000000000000000000000000000000000000000000000000 (meta)\n0004: 0x6e616d6500000000000000000000000000000000000000000000000000000000 (name)\n\n0048    54  SLOAD\nSTACK: 5\n0000: 0x0000000000000000000000000000000000000000000000000000000000000000 (slot value)\n0001: 0xf7fbcbda33204447e5b6bf43e1ab2765746799462c92f997afb4e0d6a2fab922 (slot)\n0002: 0x6461746100000000000000000000000000000000000000000000000000000000 (data)\n0003: 0x6d65746100000000000000000000000000000000000000000000000000000000 (meta)\n0004: 0x6e616d6500000000000000000000000000000000000000000000000000000000 (name)\n\n0049    60  PUSH1 0x01\nSTACK: 6\n0000: 0x01\n0001: 0x0000000000000000000000000000000000000000000000000000000000000000 (slot value)\n0002: 0xf7fbcbda33204447e5b6bf43e1ab2765746799462c92f997afb4e0d6a2fab922 (slot)\n0003: 0x6461746100000000000000000000000000000000000000000000000000000000 (data)\n0004: 0x6d65746100000000000000000000000000000000000000000000000000000000 (meta)\n0005: 0x6e616d6500000000000000000000000000000000000000000000000000000000 (name)\n\n004B    16  AND\nSTACK: 5\n0000: 0x0000000000000000000000000000000000000000000000000000000000000000\n0001: 0xf7fbcbda33204447e5b6bf43e1ab2765746799462c92f997afb4e0d6a2fab922 (slot)\n0002: 0x6461746100000000000000000000000000000000000000000000000000000000 (data)\n0003: 0x6d65746100000000000000000000000000000000000000000000000000000000 (meta)\n0004: 0x6e616d6500000000000000000000000000000000000000000000000000000000 (name)\n```\n\n11. check `calldatasize=100`\n\n```bash\n004C    36  CALLDATASIZE\nSTACK: 6\n0000: 0x0000000000000000000000000000000000000000000000000000000000000064 (calldatasize)\n0001: 0x0000000000000000000000000000000000000000000000000000000000000000 (slot filled or not)\n0002: 0xf7fbcbda33204447e5b6bf43e1ab2765746799462c92f997afb4e0d6a2fab922 (slot)\n0003: 0x6461746100000000000000000000000000000000000000000000000000000000 (data)\n0004: 0x6d65746100000000000000000000000000000000000000000000000000000000 (meta)\n0005: 0x6e616d6500000000000000000000000000000000000000000000000000000000 (name)\n\n004D    60  PUSH1 0x64\nSTACK: 7\n0000: 0x0000000000000000000000000000000000000000000000000000000000000064 (100 bytes)\n0000: 0x0000000000000000000000000000000000000000000000000000000000000064 (calldatasize)\n0001: 0x0000000000000000000000000000000000000000000000000000000000000000 (slot filled or not)\n0002: 0xf7fbcbda33204447e5b6bf43e1ab2765746799462c92f997afb4e0d6a2fab922 (slot)\n0003: 0x6461746100000000000000000000000000000000000000000000000000000000 (data)\n0004: 0x6d65746100000000000000000000000000000000000000000000000000000000 (meta)\n0005: 0x6e616d6500000000000000000000000000000000000000000000000000000000 (name)\n\n004F    18  XOR\nSTACK: 6\n0000: 0x0000000000000000000000000000000000000000000000000000000000000000 (calldatasize=100 or not)\n0001: 0x0000000000000000000000000000000000000000000000000000000000000000 (slot filled or not)\n0002: 0xf7fbcbda33204447e5b6bf43e1ab2765746799462c92f997afb4e0d6a2fab922 (slot)\n0003: 0x6461746100000000000000000000000000000000000000000000000000000000 (data)\n0004: 0x6d65746100000000000000000000000000000000000000000000000000000000 (meta)\n0005: 0x6e616d6500000000000000000000000000000000000000000000000000000000 (name)\n\n0050    17  OR\nSTACK: 5\n0000: 0x0000000000000000000000000000000000000000000000000000000000000000\n0001: 0xf7fbcbda33204447e5b6bf43e1ab2765746799462c92f997afb4e0d6a2fab922 (slot)\n0002: 0x6461746100000000000000000000000000000000000000000000000000000000 (data)\n0003: 0x6d65746100000000000000000000000000000000000000000000000000000000 (meta)\n0004: 0x6e616d6500000000000000000000000000000000000000000000000000000000 (name)\n```\n\n12. if true, jump to `0x58` and revert according to calldatasize\n\n```bash\n0051    60  PUSH1 0x58\n0053    57  *JUMPI\n```\n\n13. conditions are fulfilled, store `meta` at storage slot and return\n\n```bash\n0054    82  DUP3\nSTACK: 5\n0000: 0x6d65746100000000000000000000000000000000000000000000000000000000 (meta)\n0001: 0xf7fbcbda33204447e5b6bf43e1ab2765746799462c92f997afb4e0d6a2fab922 (slot)\n0002: 0x6461746100000000000000000000000000000000000000000000000000000000 (data)\n0003: 0x6d65746100000000000000000000000000000000000000000000000000000000 (meta)\n0004: 0x6e616d6500000000000000000000000000000000000000000000000000000000 (name)\n\n0055    81  DUP2\nSTACK: 6\n0000: 0xf7fbcbda33204447e5b6bf43e1ab2765746799462c92f997afb4e0d6a2fab922 (slot)\n0001: 0x6d65746100000000000000000000000000000000000000000000000000000000 (meta)\n0002: 0xf7fbcbda33204447e5b6bf43e1ab2765746799462c92f997afb4e0d6a2fab922 (slot)\n0003: 0x6461746100000000000000000000000000000000000000000000000000000000 (data)\n0004: 0x6d65746100000000000000000000000000000000000000000000000000000000 (meta)\n0005: 0x6e616d6500000000000000000000000000000000000000000000000000000000 (name)\n\n0056    55  SSTORE\nSTACK: 4\n0000: 0xf7fbcbda33204447e5b6bf43e1ab2765746799462c92f997afb4e0d6a2fab922 (slot)\n0001: 0x6461746100000000000000000000000000000000000000000000000000000000 (data)\n0002: 0x6d65746100000000000000000000000000000000000000000000000000000000 (meta)\n0003: 0x6e616d6500000000000000000000000000000000000000000000000000000000 (name)\n\n0057    00  *STOP\n```\n\n\u003e Jump here, if conditions aren't fulfilled i.e. either lock is set or calldata is incorrect.\n\n14. pop everything\n\n```bash\n0058    5B  JUMPDEST\nSTACK: 4\n0000: 0xf7fbcbda33204447e5b6bf43e1ab2765746799462c92f997afb4e0d6a2fab922 (slot)\n0001: 0x6461746100000000000000000000000000000000000000000000000000000000 (data)\n0002: 0x6d65746100000000000000000000000000000000000000000000000000000000 (meta)\n0003: 0x6e616d6500000000000000000000000000000000000000000000000000000000 (name)\n\n0059    50  POP\n005A    50  POP\n005B    50  POP\n005C    50  POP\n\nSTACK: 0\n```\n\n15. check if attempted to write at locked slot by checking `calldatasize=100`\n\n```bash\n005D    36  CALLDATASIZE\nSTACK: 1\n0000: 0x0000000000000000000000000000000000000000000000000000000000000064 (calldatasize)\n\n005E    60  PUSH1 0x64\nSTACK: 2\n0000: 0x64\n0001: 0x0000000000000000000000000000000000000000000000000000000000000064 (calldatasize)\n\n0060    03  SUB\nSTACK: 1\n0000: 0x0000000000000000000000000000000000000000000000000000000000000000 (calldatasize - 100)\n```\n\n17. jump to `0x74` if calldatasize was wrong\n```bash\n0061    60  PUSH1 0x74\n0063    57  *JUMPI\n```\n\n\u003e Revert if attempt to write to a locked slot.\n\n18.  push `LOCKED()` converted to 4bytes\n\n```bash\n0064    63  PUSH4 0xa1422f69\nSTACK: 1\n0000: 0x00000000000000000000000000000000000000000000000000000000a1422f69 (4byte error)\nMEMORY:\n0000: 0x000000000000000000000000be862ad9abfe6f22bcb087716c7d89a26051f74c (caller)\n0020: 0x6e616d6500000000000000000000000000000000000000000000000000000000\n```\n\n19. shift left by 224 bytes to left align the 4byte error\n\n```bash\n0069    60  PUSH1 0xe0\nSTACK: 2\n0000: 0xe0\n0001: 0x00000000000000000000000000000000000000000000000000000000a1422f69 (4byte error)\nMEMORY:\n0000: 0x000000000000000000000000be862ad9abfe6f22bcb087716c7d89a26051f74c (caller)\n0020: 0x6e616d6500000000000000000000000000000000000000000000000000000000\n\n006B    1B  SHL\nSTACK: 1\n0000: 0xa1422f6900000000000000000000000000000000000000000000000000000000\nMEMORY:\n0000: 0x000000000000000000000000be862ad9abfe6f22bcb087716c7d89a26051f74c (caller)\n0020: 0x6e616d6500000000000000000000000000000000000000000000000000000000\n```\n\n20. store the error and revert\n\n```bash\n006C    60  PUSH1 0x00\n006E    52  MSTORE\n\nSTACK: 0\nMEMORY:\n0000: 0xa1422f6900000000000000000000000000000000000000000000000000000000 (4byte error left aligned)\n0020: 0x6e616d6500000000000000000000000000000000000000000000000000000000\n\n006F    60  PUSH1 0x04\n0071    60  PUSH1 0x00\nSTACK: 2\n0000: 0x0000000000000000000000000000000000000000000000000000000000000000 (memory offset)\n0001: 0x0000000000000000000000000000000000000000000000000000000000000004 (memory length)\nMEMORY:\n0000: 0xa1422f6900000000000000000000000000000000000000000000000000000000 (4byte error left aligned)\n0020: 0x6e616d6500000000000000000000000000000000000000000000000000000000\n\n0073    FD  *REVERT\n```\n\n21. revert, if no conditions fulfilled\n\n```bash\n0074    5B  JUMPDEST\nSTACK: 0\n\n0075    60  PUSH1 0x00\n0077    80  DUP1\nSTACK: 2\n0000: 0x00 (memory offset)\n0001: 0x00 (memory length)\n\n0078    FD  *REVERT\n```\n\n22. remaining init opcodes\n\n```bash\n0079    FE    *ASSERT\n007A    A2    LOG2\n007B    64    PUSH5 0x6970667358\n0081    22    22\n0082    12    SLT\n0083    20    SHA3\n0084    47    SELFBALANCE\n0085    5E    5E\n0086    23    23\n0087    8F    DUP16\n0088    09    MULMOD\n0089    C0    C0\n008A    7B    PUSH28 0x2df011287cd0b887d9e0864657776ab6a3484c43f79237fefa64736f\n00A7    6C    PUSH13 0x634300080d0033\n```","lastmodified":"2022-09-02T07:02:55.496680174Z","tags":null},"/thoughts/eth-basics":{"title":"","content":"# Ethereum Yellow Paper\n\nTransaction based state-machine\n\nstate of the blockchain changes after executing transactions.\n\nstores states in ***state root***\n\n## Accounts\n\n20-byte hex addresses whose state is stored on the blockchain\n\nTwo types of accounts:\n\n1. EOA: externally owned account\n2. Contract Accounts\n\n## Each accounts has four parts:\n\n1. Nonce: for EOA, number of transactions sent from the address. For Contracts, number of contracts creations.\n2. Balance: amount of ether owned by the account.\n3. storageRoot: Merkle-Patricia tree that stores data related to the account. Stored in the top-level state root tree.\n4. codeHash: For EOA, hash of empty string. For contracts, hash of the init code.\n\n## Transactions\n\nPiece of data signed by an external actor.\n\nTwo types of txs:\n\n1. Transaction which result in message calls\nMessage Calls: Done by contract account, when executing `CALL` opcode.\n2. Contract creation\n\nFields in a tx:\n\n1. nonce\n2. gasLimit\n3. gasPrice\n4. to\n5. value\n6. v, r, s: signature identifying sender\n7. init: in case of contract creating tx, returns code of the contract without constructor\n8. data: in case of message call tx, data being passed in call\n\n## Blocks\n\naggregate transactions and include in the blockchain\n\nContains:\n\n1. parentHash\n2. ommerHash\n3. beneficiary\n4. stateRoot\n5. transactionsRoot\n6. receiptsRoot\n7. timestamp\n8. number\n9. difficulty\n10. gasLimit\n11. gasUsed\n12. extraData\n13. mixHash\n14. nonce\n\n## GHOST\n\n`GHOST` protocol is used by ethereum to prevent mining centralization and enhance protocol security.\n\nLongest chain isnâ€™t just the chain with more blocks as ancestor, but it also includes other stale(uncle) blocks in the calculation.\n\nUncle blocks are child of the ancestor of the block and not directly related to the block.\n\n## RLP\n\nIt is the data encoding used by the protocol to store data in tries.\nThere are several rules for encoding mentioned below.\n\n[Data structure in Ethereum | Episode 1: Recursive Length Prefix (RLP) Encoding/Decoding.](https://medium.com/coinmonks/data-structure-in-ethereum-episode-1-recursive-length-prefix-rlp-encoding-decoding-d1016832f919)\n\n## HP Encoding\n\nThis encoding is used for trie paths.\n\n[Data structure in Ethereum | Episode 1+: Compact (Hex-prefix) encoding.](https://medium.com/coinmonks/data-structure-in-ethereum-episode-1-compact-hex-prefix-encoding-12558ae02791)\n\n[Ethereum: Tutorials - LayerX Research](https://scrapbox.io/layerx/Ethereum:_Tutorials)\n\nPatricia tree\n\n[patricia-tree](https://eth.wiki/fundamentals/patricia-tree)\n[Understanding trie databases](https://medium.com/shyft-network-media/understanding-trie-databases-in-ethereum-9f03d2c3325d)\n\n","lastmodified":"2022-09-02T07:02:55.496680174Z","tags":null},"/thoughts/eth-execution":{"title":"","content":"# ETH Execution Layer\n\nTODO","lastmodified":"2022-09-02T07:02:55.496680174Z","tags":null},"/thoughts/nomad-xyz":{"title":"","content":"# [Nomad](https://nomad.xyz)\n\nProtocol for cross-chain communication. Follows **optimistic** design inspired from _Optimistic Rollups_. Nomad's design aims to solve the interoperability trilemma famously coined by Connext but introduces a new component, `latency`.\n\n## Design\n\nArchitectural design is divided into two main components:\n\n- On-chain components\n  - Home\n  - Replica\n- Off-chain components\n  - Updater\n  - Relayer\n  - Watcher\n  - Processor\n\n## Optimistic Flow\n\nNomad works with both of these components to facilitate communication between any number of chains that support user-defined computations. It takes use of _sparse merkle trees_ as data structure to pass message between the chains.\n\nThere is a source domain with `Home` contract and a destination ~~chain~~ domain with the `Replica` contract. `Home` is reponsible for generating the message on the source domain and `Replica` on the destination domain keeps a copy of the tree which gets updated when new messages are received from the source domain.\n\n\u003e Note: We'll use `domain` here instead of `chain` as Nomad is a base layer that can be used with any chains, rollups, etc.\n\nHow these messages gets passed securely is handled by the off-chain components which helps in ease of implementation and reducing the cost of these transfers by 80%. The `updater` component polls messages from the `Home` contract in the form of a merkle tree and attests it. It is then sent to the destination chain by the `Relayer`. There, it waits for some time before being added in the Replica contract which holds the current root. Since, `updater` can attest fraudulent messages, the timeout gives anyone the chance to prove the fraud which results in bond slashing of updater and all the attestations being marked as invalid.\n\nSince the messages are just a merkle tree being committed to newer messages, it can be easily rolled back. The process of timeout and `Watchers` submitting a fraud proof is done on the receiving chain because a `Relayer` doesn't know about messages at all, it's job is just to relay whatever message it receives from source chain. These fraud can be proven back to the source chain as that is the original `Source of Truth`, which slashes the `Updater` bonds.\n\nNomad rather than handling globally verified fraud proofs on the sending chain, allows fraudulent messages to pass through as then these frauds become public due to the timeout at the receiving chains. These can then easily be proven to the source chain which becomes the source of truth that these fraudulent messages where in fact, passed by the `Updater`.\n\n## Components\n\n### On-Chain Components\n\n#### `Home`\n\n- Used by other contracts to send messages using `send message` API\n- enfore message format\n- updates root by committing messages\n- maintains queue of tree roots\n- slashes `Updater` bonds\n  - Double update proofs\n  - Improper update proofs\n\n#### `Replica`\n\n- maintains queue of pending updates\n- add to new tree root after timeout elapses\n- accepts fraud proofs to validate messages\n- ensure processing of messages in proper order\n- sends messages to end recipients\n\n### Off-Chain Components\n\n#### `Updater`\n\n- polls home for new updates\n- signs or attests to new updates\n- publish to home chain\n\n#### `Relayer`\n\nrelays updates to new\n\n- Observes home to check for new updates\n- forwards the signed updates to one or more replicas\n- Observes replicas for timeout passed updates and updates relayer current root\n\n#### `Watcher`\n\nProvides security to the protocol\n\n- Submits Double/Invalid update proof\n- Observes home, to check the interaction of updater's with the Home contract to check for any malicious attestations\n- Observes replicas, so that updater doesn't directly go to replica\n\n#### `Processor`\n\nprocesses pending updates\n\n- maintains the old tree with all the details\n- creates proof for new updates\n- send proven messages to end recipients\n\n## Frauds\n\nCurrently, there are two types of fraud that can occur in the system.\n\n1. ### Improper Update\n\nOccurs when an `Updater` attests to a fake root that was not in the `Home` root's queue. Updater purpose is to send fake messages to the destination chain.\n\nThis can be easily proven by the `Watcher` by submitting the fake root and Updater sig to Home, eventually slashing Updater's bonds or at worst halting the transfers to destination chain.\n\n2. ### Double Update\n\nAn `Updater` can attest two identical roots, i.e. the roots share same sig in order to double spend the receiving chain. This gets detected by `Watcher` as the duplicate root submitted by Updater is not the part of the queue as it's already sent to the destination chain.\n\n## Token Bridge xApp Example\n\n**Source**: Chain A\n\n**Destination**: Chain B\n\n**Local Contract**: Contract on same chain\n\n**Remote Contract**: Contract on other chain\n\n- **Source**\n\n  - User approve tokens to local `BridgeRouter`\n    - If native token, held in escrow and sent to local `Home`\n    - If non-native, token burned as the contract is deployed by `BridgeRouter`\n  - Message constructed by local `BridgeRouter` to send tokens to `Destination` on `Remote BridgeRouter`\n    - It keeps mapping of bridge routers on other chains, to send message to desired receiver.\n  - enqueues message on `Home`\n\n- Off-Chain\n\n  - Updater attests to the root\n  - relayer forwards it to `Remote Replica`\n  - processor creates proof\n\n- **Destination**\n  - `Replica` processes message after timeout ends and sends message to `BridgeRouter`\n  - `BridgeRouter` verifies that it was sent by `Source BridgeRouter` as it keeps mapping of `BridgeRouter` of other chains\n  - Looks for ERC20 token in registry\n  - Sends token to recipient\n    - If native, send from tokens held in escrow\n    - If non-native, mints new tokens as the representative token contract is deployed by the `BridgeRouter`\n\n## Questions\n\n1. Why is an `Updater` called an `Updater` even tho its job is more like a validator?\n\n2. Can a `Relayer` send fraudulent updates? What if it does, and who gets slashed in that case?\n\nNo, it can't as it's job is just to relay whatever updates it polls to receiving chain.\n\n4. What are the future plans of tackling this optimistic timeout delay?\n\nRight now, this is more of a feature than a disadvantage as it makes system more robust and for implementation ease as well. Need more idea about future plans. Moreover, connext plays out an important role here to partner with Nomad and reduce this to nearly 2 mins.\n\n5. Does this `30 min` delay quantified on a basis? How is it chosen? Can it be variable on the basis of watcher numbers or some other factors? or is it fixed?\n\nResearch: https://medium.com/offchainlabs/fighting-censorship-attacks-on-smart-contracts-c026a7c0ff02\n\n6. How does a bridge handles fork on a sending chain? Does the updates get rolled back?\n\nMaybe here the timeout delay plays out as an advantage, if a fork occurs on a sending chain, the `Relayer` can mark update as invalid and it is no longer processed by `Processor`.\n\n7. Nomad assumes security on the presence of even 1 watcher, doesn't that create centralization risk? Can that 1 watcher be the same updater?\n\n8. Can Nomad leverage ETH consensus mechanisms like RANDAO to pseudo-randomly select updators and watchers?\n\n## Links\n\n- [Nomad Docs](https://docs.nomad.xyz)\n- [Optimistic Brides](https://blog.connext.network/optimistic-bridges-fb800dc7b0e0)\n- [The Cheater Checking Problem: Why the Verifierâ€™s Dilemma is Harder Than You Think](https://medium.com/offchainlabs/the-cheater-checking-problem-why-the-verifiers-dilemma-is-harder-than-you-think-9c7156505ca1)\n","lastmodified":"2022-09-02T07:02:55.496680174Z","tags":null},"/thoughts/socket-dot-tech":{"title":"","content":"# Socket Dot Tech\n\n# [**Registry.sol**](https://etherscan.io/address/0xc30141B657f4216252dc59Af2e7CdB9D8792e1B0#code)\n\n## Structs\n\n   - RouteData\n\n```other\naddress route;\nbool isEnabled;\nbool isMiddleware\n```\n\n   - MiddlewareRequest\n\n```other\nuint256 id;\nuint256 optionalNativeAmount;\naddress inputToken;\nbytes data;\n```\n\n   - BridgeRequest\n\n```other\nuint256 id;\nuint256 optionalNativeAmount;\naddress inputToken;\nbytes data;\n```\n\n   - UserRequest\n\n```other\naddress receiverAddress\nuint256 toChainId\nuint256 amount\nMiddlewareRequest middlewareRequest\nBridgeRequest bridgeRequest\n```\n\n## State Variables\n\n   - `RouteData[] routes`\n   - `NATIVE_TOKEN_ADDRESS`\n\n## Events\n\n   - NewRouteAdded\n   - RouteDisabled\n   - RouteAdded\n   - ExecutionCompleted\n\n## Functions\n\n   - addRoutes\n   - rescueFunds\n   - outboundTransferTo\n\n```other\n1. check for user amount != 0\n2. bridge ID != 0\n3. bridge input token != address(0)\n4. load middleware info and validate\n5. load bridge info and validate\n6. emit ExecutionCompleted\n7. if middlewareId is 0, then directly send to bridge\n8. then perform action through middleware to perform swap on token and transfer on registry address on the basis of inputToken\n9. grant approvals on basis of whether token == nativeToken\n10. call bridge's outboundTransferTo\n```\n\n   - disableRoute\n\n# ImplBase\n\n## State Variable\n\n- `address public registry;`\n- `address public constant NATIVE_TOKEN_ADDRESS =\naddress(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE);`\n\n### Functions\n\n- rescueFunds\n\n```other\nfunction rescueFunds(\n        address token,\n        address userAddress,\n        uint256 amount\n    ) external onlyOwner {\n        IERC20(token).safeTransfer(userAddress, amount);\n    }\n```\n\n- outboundTransferFrom\n\n```other\nfunction outboundTransferTo(\n        uint256 _amount,\n        address _from,\n        address _receiverAddress,\n        address _token,\n        uint256 _toChainId,\n        bytes memory _extraData\n    ) external payable virtual;\n```\n\n   - if token == native token address, directly send to L2 else give approvals then send to L2\n\n# MiddlewareImplBase\n\n### State Variables\n\n- `address public immutable registry;`\n- `aggregator`\n\n### Functions\n\n- performAction\n\n```other\nfunction performAction(\n        address from,\n        address fromToken,\n        uint256 amount,\n        address receiverAddress,\n        bytes memory data\n    ) external payable virtual returns (uint256);\n```\n\n- rescueFunds\n\n```other\nfunction rescueFunds(\n        address token,\n        address userAddress,\n        uint256 amount\n    ) external onlyOwner {\n        IERC20(token).safeTransfer(userAddress, amount);\n    }\n```\n\n## Eth\n\n- [Registry](https://etherscan.io/address/0xc30141B657f4216252dc59Af2e7CdB9D8792e1B0#code)\n- [HopImpl](https://etherscan.io/address/0xd286595d2e3D879596FAB51f83A702D10a6db27b#code) â†’ ImplBase\n- [NativePolygonImpl](https://etherscan.io/address/0xa7649aa944b7dce781859c18913c2dc8a97f03e4#code) â†’ ImplBase\n- [NativeArbitrumImpl](https://etherscan.io/address/0x852C5DE08b9beB014caD171C16B12a8D7456ea3f#code) â†’ ImplBase\n- [AnySwapImplL1](https://etherscan.io/address/0x040993fbF458b95871Cd2D73Ee2E09F4AF6d56bB#code) â†’ ImplBase\n- [HyphenImplL1](https://etherscan.io/address/0xBE51D38547992293c89CC589105784ab60b004A9#code) â†’ ImplBase\n- [oneInchSwapImpl](https://etherscan.io/address/0x5800249621DA520aDFdCa16da20d8A5Fc0f814d8#code) â†’ MiddlewareImplBase\n\n## Arbitrum One\n\n- Registry\n- [HopImplL2](https://arbiscan.io/address/0x2b42AFFD4b7C14d9B7C2579229495c052672Ccd3#code) â†’ ImplBase\n- [AnyswapImplL2](https://arbiscan.io/address/0x8537307810fC40F4073A12a38554D4Ff78EfFf41#code) â†’ ImplBase\n- [OneInchImpl](https://arbiscan.io/address/0x565810cbfa3Cf1390963E5aFa2fB953795686339#code) â†’ MiddlewareImplBase\n\n## Polygon\n\n- [Registry](https://polygonscan.com/address/0xc30141B657f4216252dc59Af2e7CdB9D8792e1B0#code)\n- [HopImplL2](https://polygonscan.com/address/0x2b42AFFD4b7C14d9B7C2579229495c052672Ccd3#code) â†’ ImplBase\n- [HyphenImplL2](https://polygonscan.com/address/0x565810cbfa3Cf1390963E5aFa2fB953795686339#code) â†’ ImplBase\n- [AnyswapL2Impl](https://polygonscan.com/address/0x8537307810fC40F4073A12a38554D4Ff78EfFf41#code) â†’ ImplBase\n- [OneInchSwapImpl](https://polygonscan.com/address/0xc317144DE60E6bC9455363bB09852C00bd14CD61#code) â†’ MiddlewareImplBase\n\n## Optimism Mainnet\n\n- [Registry](https://optimistic.etherscan.io/address/0xc30141B657f4216252dc59Af2e7CdB9D8792e1B0#code)\n- [HopImplL2](https://optimistic.etherscan.io/address/0x8537307810fC40F4073A12a38554D4Ff78EfFf41#code) â†’ ImplBase\n- [OneInchSwapImpl](https://optimistic.etherscan.io/address/0x565810cbfa3Cf1390963E5aFa2fB953795686339#code) â†’ MiddlewareImplBase\n\n## Fantom\n\n- [Registry](https://ftmscan.com/address/0xc30141B657f4216252dc59Af2e7CdB9D8792e1B0#code)\n- [AnyswapL2](https://ftmscan.com/address/0x2b42AFFD4b7C14d9B7C2579229495c052672Ccd3#code) â†’ ImplBase\n\n## Binance Smart Chain\n\n- [Registry](https://bscscan.com/address/0xc30141b657f4216252dc59af2e7cdb9d8792e1b0#code)\n- [AnyswapImplL2](https://bscscan.com/address/0x2b42AFFD4b7C14d9B7C2579229495c052672Ccd3#code)\n- [OneInchSwapImpl](https://bscscan.com/address/0x8537307810fC40F4073A12a38554D4Ff78EfFf41#code)\n\n## Avalanche C-Chain\n\n- [Registry](https://avascan.info/blockchain/c/address/0x2b42AFFD4b7C14d9B7C2579229495c052672Ccd3/contract)\n- [AnySwapImplL2](https://avascan.info/blockchain/c/address/0x8537307810fC40F4073A12a38554D4Ff78EfFf41/contract)\n- [HyphenImplL2](https://avascan.info/blockchain/c/address/0x565810cbfa3Cf1390963E5aFa2fB953795686339/contract)\n\n","lastmodified":"2022-09-02T07:02:55.496680174Z","tags":null}}